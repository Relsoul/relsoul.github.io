<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaScript设计模式笔记-发布-订阅模式 | Soul,灵魂,凌魂,零魂,前端学习者.热爱前端.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="google-site-verification" content="SH4xN4Sso1GVTVJpiZrKCZUlL-IJ0VF70UbRIzqEpfs" />
  <meta name="description" content="新年快乐~
定义发布-订阅模式又叫观察者模式,它定义对象间的一种一对多的依赖关系，当一个对象的状态发送改变时,所有依赖于它的对象都讲得到通知.
8.1 现实中的发布-订阅模式比如买房,售楼处与买房者的关系.不可能买房者整天打电话过去 而是售楼处记录下这些买房者的电话 一但有合适的楼层再打电话过去.
8.2 发布-订阅模式的作用在上述的例子中使用发布-订阅模式有显而易见的优点

购房者不用再每天给售">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript设计模式笔记-发布-订阅模式">
<meta property="og:url" content="http://emufan.com/2016/02/08/JavaScript设计模式笔记-发布-订阅模式/index.html">
<meta property="og:site_name" content="Soul,灵魂,凌魂,零魂,前端学习者.热爱前端.">
<meta property="og:description" content="新年快乐~
定义发布-订阅模式又叫观察者模式,它定义对象间的一种一对多的依赖关系，当一个对象的状态发送改变时,所有依赖于它的对象都讲得到通知.
8.1 现实中的发布-订阅模式比如买房,售楼处与买房者的关系.不可能买房者整天打电话过去 而是售楼处记录下这些买房者的电话 一但有合适的楼层再打电话过去.
8.2 发布-订阅模式的作用在上述的例子中使用发布-订阅模式有显而易见的优点

购房者不用再每天给售">
<meta property="og:updated_time" content="2016-02-08T13:49:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript设计模式笔记-发布-订阅模式">
<meta name="twitter:description" content="新年快乐~
定义发布-订阅模式又叫观察者模式,它定义对象间的一种一对多的依赖关系，当一个对象的状态发送改变时,所有依赖于它的对象都讲得到通知.
8.1 现实中的发布-订阅模式比如买房,售楼处与买房者的关系.不可能买房者整天打电话过去 而是售楼处记录下这些买房者的电话 一但有合适的楼层再打电话过去.
8.2 发布-订阅模式的作用在上述的例子中使用发布-订阅模式有显而易见的优点

购房者不用再每天给售">
  
    <link rel="alternative" href="/atom.xml" title="Soul,灵魂,凌魂,零魂,前端学习者.热爱前端." type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">

  <script>
        var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?d3dc74e0385a92cbaf1996f3916648ed";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();

  </script>

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">soul</a></h1>
		</hgroup>

		
		<p class="header-subtitle">前端笔记</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="http://oldblog.soulchat.cn/">老博客文章</a></li>
				        
							<li><a href="/googlesearch/">谷歌搜文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Relsoul" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/acgset/home?wvr=5" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/hun-soul" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Electron/" style="font-size: 11.67px;">Electron</a> <a href="/tags/JavaScript/" style="font-size: 18.33px;">JavaScript</a> <a href="/tags/JavaScript深入浅出/" style="font-size: 15px;">JavaScript深入浅出</a> <a href="/tags/JavaScript笔记/" style="font-size: 10px;">JavaScript笔记</a> <a href="/tags/JavaScript设计模式/" style="font-size: 20px;">JavaScript设计模式</a> <a href="/tags/JavaScript设计模式笔记-代理模式/" style="font-size: 10px;">JavaScript设计模式笔记-代理模式</a> <a href="/tags/angularJS/" style="font-size: 16.67px;">angularJS</a> <a href="/tags/angularJs/" style="font-size: 10px;">angularJs</a> <a href="/tags/es6/" style="font-size: 13.33px;">es6</a> <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/laravel/" style="font-size: 10px;">laravel</a> <a href="/tags/lnmp/" style="font-size: 10px;">lnmp</a> <a href="/tags/mac/" style="font-size: 11.67px;">mac</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mongoose/" style="font-size: 11.67px;">mongoose</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/nodejs/" style="font-size: 16.67px;">nodejs</a> <a href="/tags/php/" style="font-size: 13.33px;">php</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/socket-io/" style="font-size: 11.67px;">socket.io</a> <a href="/tags/the7/" style="font-size: 10px;">the7</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/web全栈开发工程师笔记/" style="font-size: 10px;">web全栈开发工程师笔记</a> <a href="/tags/win10/" style="font-size: 10px;">win10</a> <a href="/tags/wordpress/" style="font-size: 11.67px;">wordpress</a> <a href="/tags/个人/" style="font-size: 10px;">个人</a> <a href="/tags/学习笔记/" style="font-size: 18.33px;">学习笔记</a> <a href="/tags/微博开发笔记/" style="font-size: 10px;">微博开发笔记</a> <a href="/tags/笔记/" style="font-size: 10px;">笔记</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/读书笔记/" style="font-size: 13.33px;">读书笔记</a> <a href="/tags/阿里云/" style="font-size: 10px;">阿里云</a> <a href="/tags/随笔/" style="font-size: 13.33px;">随笔</a>
					</div>

				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://emufan.com">soul</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/vbdfforever">梦回大神的BLOG</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">搜索采用&quot;谷歌搜索&quot;~请自备梯子~ 内容基本上都为自己原创的笔记~ 喜欢就分享一下吧~</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">soul</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">soul</h1>
			</hgroup>
			
			<p class="header-subtitle">前端笔记</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="http://oldblog.soulchat.cn/">老博客文章</a></li>
		        
					<li><a href="/googlesearch/">谷歌搜文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Relsoul" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/acgset/home?wvr=5" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/hun-soul" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-JavaScript设计模式笔记-发布-订阅模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/08/JavaScript设计模式笔记-发布-订阅模式/" class="article-date">
  	<time datetime="2016-02-08T11:36:17.000Z" itemprop="datePublished">2016-02-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JavaScript设计模式笔记-发布-订阅模式
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript设计模式/">JavaScript设计模式</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>新年快乐~</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>发布-订阅模式又叫观察者模式,它定义对象间的一种一对多的依赖关系，当一个对象的状态发送改变时,所有依赖于它的对象都讲得到通知.</p>
<h1 id="8-1-现实中的发布-订阅模式"><a href="#8-1-现实中的发布-订阅模式" class="headerlink" title="8.1 现实中的发布-订阅模式"></a>8.1 现实中的发布-订阅模式</h1><p>比如买房,售楼处与买房者的关系.不可能买房者整天打电话过去 而是售楼处记录下这些买房者的电话 一但有合适的楼层再打电话过去.</p>
<h1 id="8-2-发布-订阅模式的作用"><a href="#8-2-发布-订阅模式的作用" class="headerlink" title="8.2 发布-订阅模式的作用"></a>8.2 发布-订阅模式的作用</h1><p>在上述的例子中使用发布-订阅模式有显而易见的优点</p>
<ul>
<li>购房者不用再每天给售楼处打电话咨询问题.售楼处会作为发布者通知这些消息订阅者</li>
<li>购房者和售楼处之间不再强耦合在一起,当有新的购房者出现的时候,他只需要把手机号留给售楼处.不管售楼处换了几个售楼MM离职都不会影响购房者</li>
</ul>
<p>第一点说明发布-订阅模式可以广泛应用各种异步编程中,这是一种替代传递回调函数的方案.比如ajax请求中的error,succ事件.<br>第二点说明发布-订阅模式可以取代对象之间的硬编码的通知机制.一个对象不再显式调用另一个对象的某个接口.</p>
<a id="more"></a>
<h1 id="8-3-DOM事件"><a href="#8-3-DOM事件" class="headerlink" title="8.3 DOM事件"></a>8.3 DOM事件</h1><p>实际上DOM事件就是一种发布-订阅模式的实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.addEventListener( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="number">2</span>);</div><div class="line">&#125;, <span class="literal">false</span> );</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.click(); <span class="comment">// 模拟用户点击</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.addEventListener( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="number">2</span>);</div><div class="line">&#125;, <span class="literal">false</span> );</div><div class="line"><span class="built_in">document</span>.body.addEventListener( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="number">112</span> 第<span class="number">8</span> 章 发布订阅模式</div><div class="line">    alert(<span class="number">3</span>);</div><div class="line">&#125;, <span class="literal">false</span> );</div><div class="line"><span class="built_in">document</span>.body.addEventListener( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="number">4</span>);</div><div class="line">&#125;, <span class="literal">false</span> );</div></pre></td></tr></table></figure></p>
<p>这里不过多记笔记..直接来实现吧.</p>
<h1 id="8-4-自定义事件"><a href="#8-4-自定义事件" class="headerlink" title="8.4 自定义事件"></a>8.4 自定义事件</h1><p>除了DOM事件,我们还会经常实现一些自定义事件,这种依靠自定义事件完成的发布-订阅模式可以用于任何JavaScript代码中.</p>
<p>实现发布-订阅模式的步骤</p>
<ul>
<li>首先要指定好谁充当发布者（比如售楼处）</li>
<li>然后给发布者添加一个缓冲列表,用于存放回调函数以便通知订阅者(售楼处的花名册)</li>
<li>最后发布消息的时候,发布者会遍历这个缓存列表,依次触发里面存放的订阅者回调函数.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> salesOffices=&#123;&#125;;<span class="comment">//定义售楼处</span></div><div class="line"></div><div class="line">salesOffices.clientList=[];</div><div class="line"></div><div class="line">salesOffices.listen=<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;<span class="comment">//增加订阅者</span></div><div class="line">    <span class="keyword">this</span>.clientList.push(fn)<span class="comment">//订阅的消息添加进缓存列表</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">salesOffices.trigger=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//发布消息</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,fn;fn=<span class="keyword">this</span>.clientList[i++])&#123;</div><div class="line">        fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);<span class="comment">//arguments是发布消息时带上的参数</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来进行一些简单的测试<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面我们来进行一些简单的测试：</span></div><div class="line">    <span class="selector-tag">salesOffices</span><span class="selector-class">.listen</span>( function( price, squareMeter )&#123; <span class="comment">// 小明订阅消息</span></div><div class="line">        console<span class="selector-class">.log</span>( <span class="string">'价格= '</span> + price );</div><div class="line">        console<span class="selector-class">.log</span>( <span class="string">'squareMeter= '</span> + squareMeter );</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="selector-tag">salesOffices</span><span class="selector-class">.listen</span>( function( price, squareMeter )&#123; <span class="comment">// 小红订阅消息</span></div><div class="line">        console<span class="selector-class">.log</span>( <span class="string">'价格= '</span> + price );</div><div class="line"></div><div class="line">        console<span class="selector-class">.log</span>( <span class="string">'squareMeter= '</span> + squareMeter );</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="selector-tag">salesOffices</span><span class="selector-class">.trigger</span>( <span class="number">2000000</span>, <span class="number">88</span> ); <span class="comment">// 输出：200 万，88 平方米</span></div><div class="line">    <span class="selector-tag">salesOffices</span><span class="selector-class">.trigger</span>( <span class="number">3000000</span>, <span class="number">110</span> ); <span class="comment">// 输出：300 万，110 平方米</span></div></pre></td></tr></table></figure></p>
<p>但是上述的发布订阅模式还不完善 因为比如只想订阅一个88平方米这个房子消息,却输出了110平方米的 这个是不合适的.<br>所以有必要增加一个标示key<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> salesOffices=&#123;&#125;;<span class="comment">//定义售楼处</span></div><div class="line">salesOffices.clientList=&#123;&#125;;<span class="comment">//缓存列表,用来存放订阅者的回调函数</span></div><div class="line"></div><div class="line">salesOffices.listen=<span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.clientList[key])&#123;</div><div class="line">        <span class="keyword">this</span>.clientList[key]=[];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.clientList[key].push(fn)</div><div class="line">&#125;</div><div class="line"></div><div class="line">salesOffices.trigger=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> key=[].shift.call(<span class="built_in">arguments</span>);<span class="comment">//取出消息列表</span></div><div class="line">        fns=<span class="keyword">this</span>.clientList[key];<span class="comment">//缓存列表</span></div><div class="line">    <span class="keyword">if</span>(!fns||fns.length==<span class="number">0</span>)&#123;<span class="comment">//没有订阅该消息则返回</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,fn;fn=fns[i++];)&#123;</div><div class="line">        fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);<span class="comment">//arguments是发布消息时带上的参数</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    salesOffices.listen( <span class="string">'squareMeter88'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小明订阅88 平方米房子的消息</span></div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price ); <span class="comment">// 输出： 2000000</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    salesOffices.listen( <span class="string">'squareMeter110'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小红订阅110 平方米房子的消息</span></div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price ); <span class="comment">// 输出： 3000000</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    salesOffices.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 发布88 平方米房子的价格</span></div><div class="line">    salesOffices.trigger( <span class="string">'squareMeter110'</span>, <span class="number">3000000</span> ); <span class="comment">// 发布110 平方米房子的价格</span></div></pre></td></tr></table></figure></p>
<p>这样订阅者就可以定义自己感兴趣的事情了.</p>
<h1 id="8-5-发布-订阅模式的通用实现"><a href="#8-5-发布-订阅模式的通用实现" class="headerlink" title="8.5 发布-订阅模式的通用实现"></a>8.5 发布-订阅模式的通用实现</h1><p>这段代码在salesOffices这个对象上实现的,但是我想在salesPeople（笑）这个对象上实现呢..是否必须重写对象?答案是不必的 只需要执行一个安装函数<br>这里用继承也可以实现吧?</p>
<p>我们先把通用代码提取出来,单独放在一个对象中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> event=&#123;</div><div class="line">    clientList:[],</div><div class="line">    listen:<span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.clientList[key])&#123;</div><div class="line">            <span class="keyword">this</span>.clientList[key]=[];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.clientList[key].push(fn)<span class="comment">//添加进缓存列表</span></div><div class="line">    &#125;,</div><div class="line">    trigger:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> key=[].shift.call(<span class="built_in">arguments</span>);<span class="comment">//取出消息列表</span></div><div class="line">        fns=<span class="keyword">this</span>.clientList[key];<span class="comment">//缓存列表</span></div><div class="line">        <span class="keyword">if</span>(!fns||fns.length==<span class="number">0</span>)&#123;<span class="comment">//没有订阅该消息则返回</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,fn;fn=fns[i++];)&#123;</div><div class="line">            fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);<span class="comment">//arguments是发布消息时带上的参数</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//定义一个安装函数</span></div><div class="line"><span class="keyword">var</span> installEvent=<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> event)&#123;</div><div class="line">        obj[i]=event[i]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上这个安装函数就是copy功能..但是这个copy又分浅拷贝和深拷贝.这里不做解释.有兴趣的可以去看看jquery的extend<br>再来测试一下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//再来测试一番，我们给售楼处对象salesOffices 动态增加发布—订阅功能：</span></div><div class="line">    <span class="keyword">var</span> salesOffices = &#123;&#125;;</div><div class="line">    installEvent( salesOffices );</div><div class="line">    salesOffices.listen( <span class="string">'squareMeter88'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小明订阅消息</span></div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price );</div><div class="line">    &#125;);</div><div class="line">    salesOffices.listen( <span class="string">'squareMeter100'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小红订阅消息</span></div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price );</div><div class="line">    &#125;);</div><div class="line">    salesOffices.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 输出：2000000</span></div><div class="line">    salesOffices.trigger( <span class="string">'squareMeter100'</span>, <span class="number">3000000</span> ); <span class="comment">// 输出：3000000</span></div></pre></td></tr></table></figure></p>
<h1 id="8-6-取消订阅的事件"><a href="#8-6-取消订阅的事件" class="headerlink" title="8.6 取消订阅的事件"></a>8.6 取消订阅的事件</h1><p>比如DOM操作中的removeListen这个函数一样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">event.remove=<span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> fns=<span class="keyword">this</span>.clientList[key];</div><div class="line">    <span class="keyword">if</span>(!fns||fns.length==<span class="number">0</span>)&#123;<span class="comment">//如果key对应的消息没有被人订阅 则直接返回false</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!fn)&#123;<span class="comment">//如果没有传入具体的回调函数,则表示需要取消key对应消息的所有订阅</span></div><div class="line">        fns&amp;&amp;(fns.length==<span class="number">0</span>)<span class="comment">//这里的&amp;&amp;运算符始终会返回最后一个数值 也就是说会执行fns和fns.length==0 其中有一个为false则不执行下一个</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> l=fns.length<span class="number">-1</span>;l&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//反向遍历订阅的回调函数列表</span></div><div class="line">            <span class="keyword">var</span> _fn=fns[l];</div><div class="line">            <span class="keyword">if</span>(_fn===fn)&#123;</div><div class="line">                fns.splice(l,<span class="number">1</span>);<span class="comment">//删除订阅者的回调函数</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    installEvent( salesOffices );</div><div class="line"></div><div class="line">    salesOffices.listen( <span class="string">'squareMeter88'</span>, fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小明订阅消息</span></div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price );</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    salesOffices.listen( <span class="string">'squareMeter88'</span>, fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小红订阅消息</span></div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price );</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    salesOffices.remove( <span class="string">'squareMeter88'</span>, fn1 ); <span class="comment">// 删除小明的订阅</span></div><div class="line">    salesOffices.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 输出：2000000</span></div></pre></td></tr></table></figure></p>
<p>这里判断删除也就是说移除的办法是 判断移除时候传递的回调函数是否等于绑定时候的回调函数</p>
<h1 id="8-7-真实的例子——网站登陆"><a href="#8-7-真实的例子——网站登陆" class="headerlink" title="8.7 真实的例子——网站登陆"></a>8.7 真实的例子——网站登陆</h1><p>比如一个网站有header,nav,message等模块 且这些模块的内容是ajax加载后才生成的.<br>单纯的异步回调函数会造成一种耦合性 比如<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">login</span><span class="selector-class">.succ</span>(function(data)&#123;</div><div class="line">    header<span class="selector-class">.setAvatar</span>(data.avatar);<span class="comment">//设置header模块的头像</span></div><div class="line">    nav<span class="selector-class">.setAvater</span>(data.avatar);<span class="comment">//设置导航模块的头像</span></div><div class="line">    message<span class="selector-class">.refresh</span>();<span class="comment">//刷新消息列表</span></div><div class="line">    cart<span class="selector-class">.refresh</span>();<span class="comment">//刷新购物车列表</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这里就会有一种耦合性.因为setAvatar这个方法我们不能变更 一变更各个地方都需要变更 而且当需要加载的模块越来越多 这个回调函数也会越来越大<br>比如某天需要增加一个收获地址列表于是又得在这个回调函数中加上一个更新函数<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">login</span><span class="selector-class">.succ</span>(function(data)&#123;</div><div class="line">    header<span class="selector-class">.setAvatar</span>(data.avatar);<span class="comment">//设置header模块的头像</span></div><div class="line">    nav<span class="selector-class">.setAvater</span>(data.avatar);<span class="comment">//设置导航模块的头像</span></div><div class="line">    message<span class="selector-class">.refresh</span>();<span class="comment">//刷新消息列表</span></div><div class="line">    cart<span class="selector-class">.refresh</span>();<span class="comment">//刷新购物车列表</span></div><div class="line">    address<span class="selector-class">.refresh</span>();<span class="comment">//刷新地址</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>用了发布-订阅模式重写后,对用户信息感兴趣的业务模块将自行订阅登陆成功的消息事件,当登陆成功后,登陆模块只需要发布登陆成功的消息,而业务方接受到消息之后,就会开始进行各自的业务处理。登陆模块并不关心业务方究竟要做什么,也不想去了解它们内部的细节.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.ajax(<span class="string">"http://xxx.com?login"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="comment">//登陆成功</span></div><div class="line">    login.trigger(<span class="string">"loginSucc"</span>,data);<span class="comment">//发布登陆成功的消息</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>各个模块监听登陆成功的消息<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> header=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//header模块</span></div><div class="line">    login.listen(<span class="string">"loginSucc"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">        header.setAvatar(data.avatar)</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">        setAvatar:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"设置header模块的头像"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)()</div><div class="line"><span class="keyword">var</span> nav = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// nav 模块</span></div><div class="line">    login.listen( <span class="string">'loginSucc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123;</div><div class="line">        nav.setAvatar( data.avatar );</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        setAvatar: <span class="function"><span class="keyword">function</span>(<span class="params"> avatar </span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log( <span class="string">'设置nav 模块的头像'</span> );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> address = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// nav 模块</span></div><div class="line">    login.listen( <span class="string">'loginSucc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</div><div class="line">        address.refresh( obj );</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        refresh: <span class="function"><span class="keyword">function</span>(<span class="params"> avatar </span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log( <span class="string">'刷新收货地址列表'</span> );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>就算事后需要增加其他模块都不需要往login中塞填函数了.</p>
<h1 id="8-8-全局的发布-订阅对象"><a href="#8-8-全局的发布-订阅对象" class="headerlink" title="8.8 全局的发布-订阅对象"></a>8.8 全局的发布-订阅对象</h1><p>刚刚编写的发布订阅函数还存在两个问题</p>
<ul>
<li>我们给每个发布者对象都添加了listen和trigger方法,以及一个缓存列表clientList，这其实是一种资源浪费</li>
<li>购房者跟售楼处还存在一定的耦合性 购房者必须要知道售楼处对象名字是salesOffices才能顺利订阅到事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">salesOffices.listen(<span class="string">"squareMeter100"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">price</span>)</span>&#123;<span class="comment">//小明订阅消息</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"价格:"</span>,price)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果小明(购房者)需要订阅300平方米的消息 而这套房子的卖家是salesOffice2 这意味着小明要开始订阅salesOffices2对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">salesOffices2.listen(<span class="string">"squareMeter300"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">price</span>)</span>&#123;<span class="comment">//小明订阅消息</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"价格:"</span>,price)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在现实中买房都未必要去售楼处 都是通过中介公司.<br>同样,在程序中我们也可以用一个中介公司来实现发布和订阅,订阅者不需要了解消息来自哪个发布者,Event类似于一个中介的角色,把发布者和订阅者联系起来<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">var</span> Event=(function()&#123;</div><div class="line">    <span class="built_in">var</span> clientList=&#123;&#125;,</div><div class="line">        listen,</div><div class="line">        trigger,</div><div class="line">        <span class="built_in">remove</span>;</div><div class="line">    listen=function(<span class="built_in">key</span>,fn)&#123;</div><div class="line">        <span class="keyword">if</span>(!clientList[<span class="built_in">key</span>])&#123;</div><div class="line">            clientList[<span class="built_in">key</span>]=[];</div><div class="line">        &#125;</div><div class="line">        clientList[<span class="built_in">key</span>].<span class="built_in">push</span>(fn)</div><div class="line">    &#125;;</div><div class="line">    trigger = function()&#123;</div><div class="line">        <span class="built_in">var</span> <span class="built_in">key</span> = Array.prototype.shift.call( arguments ),</div><div class="line">        fns = clientList[ <span class="built_in">key</span> ];</div><div class="line">        <span class="keyword">if</span> ( !fns || fns.<span class="built_in">length</span> === <span class="number">0</span> )&#123;</div><div class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>( <span class="built_in">var</span> i = <span class="number">0</span>, fn; fn = fns[ i++ ]; )&#123;</div><div class="line">            fn.<span class="built_in">apply</span>( this, arguments );</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">remove</span> = function( <span class="built_in">key</span>, fn )&#123;</div><div class="line">        <span class="built_in">var</span> fns = clientList[ <span class="built_in">key</span> ];</div><div class="line">        <span class="keyword">if</span> ( !fns )&#123;</div><div class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ( !fn )&#123;</div><div class="line">            fns &amp;&amp; ( fns.<span class="built_in">length</span> = <span class="number">0</span> );</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">for</span> ( <span class="built_in">var</span> l = fns.<span class="built_in">length</span> - <span class="number">1</span>; l &gt;=<span class="number">0</span>; l-- )&#123;</div><div class="line">                <span class="built_in">var</span> _fn = fns[ l ];</div><div class="line">                <span class="keyword">if</span> ( _fn === fn )&#123;</div><div class="line">                    fns.<span class="built_in">splice</span>( l, <span class="number">1</span> );</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">return</span> &#123;</div><div class="line">        listen: listen,</div><div class="line">        trigger: trigger,</div><div class="line">        <span class="built_in">remove</span>: <span class="built_in">remove</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;)()</div></pre></td></tr></table></figure></p>
<p>..观察这个函数…实际上就封装了一层. 核心代码并没有变.就不做进一步解释了.</p>
<h1 id="8-9-模块间通信"><a href="#8-9-模块间通信" class="headerlink" title="8.9 模块间通信"></a>8.9 模块间通信</h1><p>比如现在我们有两个点击元素<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"count"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById( <span class="string">'count'</span> );</div><div class="line">        <span class="number">120</span> 第<span class="number">8</span> 章 发布订阅模式</div><div class="line">        button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            Event.trigger( <span class="string">'add'</span>, count++ );</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">    <span class="keyword">var</span> b = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById( <span class="string">'show'</span> );</div><div class="line">        Event.listen( <span class="string">'add'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> count </span>)</span>&#123;</div><div class="line">            div.innerHTML = count;</div><div class="line">        &#125;);</div><div class="line">    &#125;)();</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们用订阅——发布模式来做数据通信.但这样会引发一个问题,模块之间如果用了太多的全局发布-订阅模式来通信就会搞不清消息来自哪个模块 而导致后期维护变得比较困难</p>
<h1 id="8-10-必须订阅再发布吗"><a href="#8-10-必须订阅再发布吗" class="headerlink" title="8.10 必须订阅再发布吗"></a>8.10 必须订阅再发布吗</h1><p>类似于QQ离线消息一样,当检测到订阅者则先建立一个离线事件的堆,当事件发布的时候,如果此时还没有订阅者来定义这个事件,我们暂时把发布事件的工作包裹在一个函数里,这些包装函数将被存入堆,等到终于有对象来订阅此事件的时候,我们将遍历离线事件堆栈并且一次执行这些包装函数..当然离线事件的生命周期只有一次,就像QQ的未读消息只会被重新阅读一次,所以我们的操作只能进行一次.</p>
<h1 id="8-11-全局事件的命名冲突"><a href="#8-11-全局事件的命名冲突" class="headerlink" title="8.11 全局事件的命名冲突"></a>8.11 全局事件的命名冲突</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先发布后订阅</span></div><div class="line">Event<span class="selector-class">.trigger</span>(<span class="string">"click"</span>,<span class="number">1</span>);</div><div class="line"><span class="selector-tag">Event</span><span class="selector-class">.listen</span>(<span class="string">"click"</span>,function(a)&#123;</div><div class="line">        console<span class="selector-class">.log</span>(a);<span class="comment">//1</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//使用命名空间</span></div><div class="line"></div><div class="line"><span class="selector-tag">Event</span><span class="selector-class">.create</span>(<span class="string">"namespace1"</span>)<span class="selector-class">.listen</span>(<span class="string">"click"</span>,function(a)&#123;</div><div class="line">        console<span class="selector-class">.log</span>(a);<span class="comment">//1</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="selector-tag">Event</span><span class="selector-class">.create</span>(<span class="string">"namespace1"</span>)<span class="selector-class">.trigger</span>(<span class="string">"click"</span>,<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="selector-tag">Event</span><span class="selector-class">.create</span>(<span class="string">"namespace2"</span>)<span class="selector-class">.listen</span>(<span class="string">"click"</span>,function(a)&#123;</div><div class="line">        console<span class="selector-class">.log</span>(a);<span class="comment">//2</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="selector-tag">Event</span><span class="selector-class">.create</span>(<span class="string">"namespace2"</span>)<span class="selector-class">.trigger</span>(<span class="string">"click"</span>,<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>第一段函数没有创建命名空间来监听和触发函数 实际上内部已经创建了一个命名空间为default,当先发布的时候实际上会添加进一个offlineStack这个堆里面,当监听的时候检测到有offlineStack则会先触发所有的离线事件…(话说每次监听都会触发离线事件)而且监听一次后则会把所有的离线事件清空 那遇到这种情况怎么办?)<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Event<span class="selector-class">.trigger</span>(<span class="string">"click"</span>,<span class="number">1</span>);</div><div class="line"><span class="selector-tag">Event</span><span class="selector-class">.trigger</span>(<span class="string">"click2"</span>,<span class="number">2</span>)</div><div class="line"><span class="selector-tag">Event</span><span class="selector-class">.listen</span>(<span class="string">"click"</span>,function(a)&#123;</div><div class="line">        console<span class="selector-class">.log</span>(a);<span class="comment">//1</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这种情况因为当监听的时候会清除所有的离线事件 那么这个click2没有进行监听就算下次再监听也会被清除. 也就是说只支持缓存一次离线事件</p>
<p>下面哪种情况也是一样的 不多说.</p>
<p>具体代码实现如下:(作者仅仅放出了函数代码,并未做解释..本渣渣来读一读代码)<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Event=(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> global=<span class="keyword">this</span>,</div><div class="line">        Event,</div><div class="line">        _default=<span class="string">"default"</span>;<span class="comment">//没有使用命名空间或者创建命名空间未传递名字时候使用的默认的命名空间</span></div><div class="line"></div><div class="line">    <span class="comment">//Event这个是封装函数 所有的方法都在Event函数里</span></div><div class="line">    Event=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">var</span> _listen,<span class="comment">//监听函数</span></div><div class="line">            _trigger,<span class="comment">//触发函数</span></div><div class="line">            _remove,<span class="comment">//移除函数</span></div><div class="line">            _slice=Array.prototype.slice,<span class="comment">//数组操作工具方法</span></div><div class="line">            _shift=Array.prototype.shift,<span class="comment">//数组操作工具方法</span></div><div class="line">            _unshift=Array.prototype.unshift,<span class="comment">////数组操作工具方法</span></div><div class="line">            namespaceCache=&#123;&#125;,<span class="comment">//命名空间</span></div><div class="line">            _create,<span class="comment">//创建命名空间函数</span></div><div class="line">            find,<span class="comment">//</span></div><div class="line">            <span class="keyword">each</span>=<span class="function"><span class="keyword">function</span><span class="params">(ary,fn)</span></span>&#123;<span class="comment">//遍历工具函数</span></div><div class="line">                <span class="comment">//ary:数组,fn:遍历回调函数</span></div><div class="line">                <span class="keyword">var</span> ret;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;l=ary.length;i&lt;l;i++)&#123;</div><div class="line">                    <span class="keyword">var</span> n=arr[i];<span class="comment">//数组元素</span></div><div class="line">                    ret=fn.call(n,i,n);<span class="comment">//回调函数传递参数 数组下标i 数组元素n 作用域为n 后面的_create中this()看这段解释会比较有用</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> ret;<span class="comment">//返回最后一个回调函数的执行结果</span></div><div class="line">            &#125;;</div><div class="line">            </div><div class="line">            _listen=<span class="function"><span class="keyword">function</span><span class="params">(key,fn,cache)</span></span>&#123;</div><div class="line">                <span class="keyword">if</span>(!cache[key])&#123; <span class="comment">//没有订阅该事件则创建</span></div><div class="line">                    cache[key]=[];</div><div class="line">                &#125;</div><div class="line">                cache[key].push(fn);<span class="comment">//添加订阅者</span></div><div class="line">            &#125;;</div><div class="line"></div><div class="line">            _remove=<span class="function"><span class="keyword">function</span><span class="params">(key,cache,fn)</span></span>&#123;</div><div class="line">                <span class="keyword">if</span>(cache[key])&#123;<span class="comment">//是否已经定义了事件</span></div><div class="line">                    <span class="keyword">if</span>(fn)&#123;<span class="comment">//如果移除的时候传递了fn那么就删除cache中对应的订阅者</span></div><div class="line">                        <span class="keyword">for</span>(<span class="keyword">var</span> i=cache[key].length;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//反向遍历</span></div><div class="line">                            <span class="keyword">if</span>(cache[key][i]===fn)&#123;<span class="comment">//如果存在则删除</span></div><div class="line">                                cache[key].splice(i,<span class="number">1</span>)</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有传递fn那么则定因为删除该事件中所有的订阅者</span></div><div class="line">                        cache[key]=[]</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            _trigger=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;<span class="comment">//临时的发布函数</span></div><div class="line">                <span class="keyword">var</span> cache=_shift.call(arguments),</div><div class="line">                    key=_shift.call(arguments),</div><div class="line">                    args=arguments,<span class="comment">//传递的</span></div><div class="line">                    _self=<span class="keyword">this</span>,</div><div class="line">                    ret,</div><div class="line">                    stack=cache[key];<span class="comment">//触发的事件堆</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span>(!stack||!stack.length)&#123;<span class="comment">//如果不存在该事件 则返回</span></div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="keyword">each</span>(stack,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;<span class="comment">//遍历事件堆 分别发布事件 这里的this指向的是stack[key]中的函数</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.apply(_self,args);</div><div class="line">                &#125;)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            _create=<span class="function"><span class="keyword">function</span><span class="params">(namespace)</span></span>&#123;</div><div class="line">                <span class="keyword">var</span> <span class="keyword">namespace</span>=<span class="keyword">namespace</span>||_default;<span class="comment">//设置命名空间</span></div><div class="line">                <span class="keyword">var</span> cache=&#123;&#125;,<span class="comment">//缓存</span></div><div class="line">                    offlineStack=[],<span class="comment">//离线事件</span></div><div class="line">                    ret=&#123;</div><div class="line">                        listen:<span class="function"><span class="keyword">function</span><span class="params">(key,fn,last)</span></span>&#123;<span class="comment">//命名空间的监听函数</span></div><div class="line">                            _listen(key,fn,cache)<span class="comment">//这里传递的缓存是命令空间的缓存 每个命令空间都会有自己的缓存</span></div><div class="line">                            <span class="keyword">if</span>(offlineStack===<span class="literal">null</span>)&#123;<span class="comment">//不存在离线事件</span></div><div class="line">                                <span class="keyword">return</span> ;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span>(last===<span class="string">"last"</span>)&#123;</div><div class="line">                                offlineStack.length&amp;&amp;offlineStack.pop()();<span class="comment">//弹出和执行最后一条离线消息事件</span></div><div class="line">                            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                                <span class="keyword">each</span>(offlineStack,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">                                    <span class="keyword">this</span>();<span class="comment">//执行每条离线事件 每个离线消息都是一个function</span></div><div class="line">                                &#125;)</div><div class="line">                            &#125;</div><div class="line">                            offlineStack=<span class="literal">null</span>;<span class="comment">//清除离线消息缓存</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;,</div><div class="line">                    one:<span class="function"><span class="keyword">function</span><span class="params">(key,fn,last)</span></span>&#123;<span class="comment">//命名空间 监听一次函数 类似于jquery.one</span></div><div class="line">                            _remove(key,cache);<span class="comment">//没有传递fn那么则定因为删除该事件堆中所有的订阅者</span></div><div class="line">                            <span class="keyword">this</span>.listen(key,fn,last);<span class="comment">//重新创建监听函数</span></div><div class="line">                    &#125;,</div><div class="line">                    remove:<span class="function"><span class="keyword">function</span><span class="params">(key,fn)</span></span>&#123;</div><div class="line">                            _remove(key,cache,fn);<span class="comment">//传递fn那么则定因为删除该事件堆中的订阅者</span></div><div class="line">                    &#125;,</div><div class="line">                    trigger:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">                        <span class="keyword">var</span> fn,</div><div class="line">                            args,</div><div class="line">                            _self=<span class="keyword">this</span>;</div><div class="line">                        _unshift.call(arguments,cache);<span class="comment">//把cache添加进arguments中</span></div><div class="line">                        args=arguments;</div><div class="line">                        fn=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">                            <span class="keyword">return</span> _trigger.apply(_self,args);<span class="comment">//触发函数 这里在去看_trigger 那么就比较好解释了为什么会弹出两次arguments</span></div><div class="line">                        &#125;;</div><div class="line">                        <span class="keyword">if</span>(offlineStack)&#123;<span class="comment">//如果离线事件存在话</span></div><div class="line">                            <span class="keyword">return</span> offlineStack.push(fn)<span class="comment">//添加进离线事件</span></div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">return</span> fn();<span class="comment">//返回当前fn函数</span></div><div class="line">                    &#125;;</div><div class="line"></div><div class="line">                <span class="comment">//给全局的namespace添加上当前的ret函数 下次调用则直接从全局的namespace查找然后返回相应的ret</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">namespace</span>?(namespaceCache[<span class="keyword">namespace</span>]?namespaceCache[<span class="keyword">namespace</span>]:namespaceCache[<span class="keyword">namespace</span>]=ret):ret</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> &#123;<span class="comment">//返回接口</span></div><div class="line">                create: _create,</div><div class="line">                one: <span class="function"><span class="keyword">function</span><span class="params">( key,fn, last )</span></span>&#123;</div><div class="line">                    <span class="keyword">var</span> event = <span class="keyword">this</span>.create( );<span class="comment">//每次都创建了命名空间</span></div><div class="line">                    event.one( key,fn,last );</div><div class="line">                &#125;,</div><div class="line">                remove: <span class="function"><span class="keyword">function</span><span class="params">( key,fn )</span></span>&#123;</div><div class="line">                    <span class="keyword">var</span> event = <span class="keyword">this</span>.create( );</div><div class="line">                    event.remove( key,fn );</div><div class="line">                &#125;,</div><div class="line">                listen: <span class="function"><span class="keyword">function</span><span class="params">( key, fn, last )</span></span>&#123;</div><div class="line">                    <span class="keyword">var</span> event = <span class="keyword">this</span>.create( );</div><div class="line">                    event.listen( key, fn, last );</div><div class="line">                &#125;,</div><div class="line">                trigger: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">                    <span class="keyword">var</span> event = <span class="keyword">this</span>.create( );</div><div class="line">                    event.trigger.apply( <span class="keyword">this</span>, arguments );</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">    &#125;()</div><div class="line">    <span class="keyword">return</span> Event</div><div class="line">&#125;)()</div></pre></td></tr></table></figure></p>
<h1 id="8-13-小结"><a href="#8-13-小结" class="headerlink" title="8.13 小结"></a>8.13 小结</h1><p>发布-订阅模式优点非常明显,一为时间上的解耦,二为对象之间的解耦.它的应用非常广泛,既可以用在异步编程中,也可以帮助我们完成更加松耦合的代码编写.MVC MVVM这些框架也离不开发布-订阅模式的参与 而且JavaScript本身也是一门基于事件驱动的语言.<br>当然 如果过度使用这种模式 特别是有多个发布者和订阅者嵌套在一起的时候 要跟踪一个bug不是一件轻松的事情</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/02/08/为什么我会推荐读书/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          为什么我会推荐读书
        
      </div>
    </a>
  
  
    <a href="/2016/02/06/JavaScript设计模式笔记-迭代器模式/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">JavaScript设计模式笔记-迭代器模式</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="JavaScript设计模式笔记-发布-订阅模式" data-title="JavaScript设计模式笔记-发布-订阅模式" data-url="http://emufan.com/2016/02/08/JavaScript设计模式笔记-发布-订阅模式/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"relsoul"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 soul
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>

</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>