<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Soul的随笔</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Soul的随笔">
<meta property="og:url" content="http://emufan.com/page/4/index.html">
<meta property="og:site_name" content="Soul的随笔">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Soul的随笔">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Soul的随笔" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?aa495dca780db3bca4942d20b6eda966";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Soul</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/了不起的nodejs读书笔记/" style="font-size: 10px;">了不起的nodejs读书笔记</a> <a href="/tags/自言语/" style="font-size: 10px;">自言语</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://emufan.com/">soul随笔</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Soul</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Soul</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-201ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/201ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/201ver/">【转】阮一峰大师的Javascript 面向对象编程（一）：封装</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通俗易懂 转自<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html</a></p><br><p>学习Javascript，最难的地方是什么？</p><br><p>我觉得，Object（对象）最难。因为Javascript的Object模型很独特，和其他语言都不一样，初学者不容易掌握。</p><br><p>下面就是我的学习笔记，希望对大家学习这个部分有所帮助。我主要参考了以下两本书籍：</p><br><p><img src="http://image.beekka.com/blog/201005/bg2010051701.jpg" data-original="http://image.beekka.com/blog/201005/bg2010051701.jpg" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt=""></p><br><p><a href="https://www.packtpub.com/object-oriented-javascript-applications-libraries/book" target="_blank">《面向对象的Javascript》</a>（Object-Oriented JavaScript）</p><br><p><img src="http://image.beekka.com/blog/201005/bg2010051702.jpg" data-original="http://image.beekka.com/blog/201005/bg2010051702.jpg" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt=""></p><br><p><a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-JavaScript-for-Web-Developers-2nd-Edition.productCd-047022780X.html" target="_blank">《Javascript高级程序设计（第二版）》</a>（Professional JavaScript for Web Developers, 2nd Edition)</p><br><p>它们都是非常优秀的Javascript读物，推荐阅读。</p><br><p>笔记分成三部分。今天的第一部分是讨论”封装”（Encapsulation），后面的<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank">第二部分</a>和<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank">第三部分</a>讨论”继承”（Inheritance）。</p><br><p>============================</p><br><p><strong>Javascript 面向对象编程（一）：封装</strong></p><br><p>作者：阮一峰</p><br><p>Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。</p><br><p>那么，如果我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？</p><br><p><strong>一、 生成对象的原始模式</strong></p><br><p>假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。</p><br><blockquote><p>　　var Cat = {</p><br><p>name : ‘’,</p><br><p>color : ‘’</p><br><p>}</p></blockquote><br><p>现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。</p><br><blockquote><p>　　var cat1 = {}; // 创建一个空对象</p><br><p>cat1.name = “大毛”; // 按照原型对象的属性赋值</p><br><p>cat1.color = “黄色”;</p><br><p>var cat2 = {};</p><br><p>cat2.name = “二毛”;</p><br><p>cat2.color = “黑色”;</p></blockquote><br><p>好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p><br><p><strong>二、 原始模式的改进</strong></p><br><p>我们可以写一个函数，解决代码重复的问题。</p><br><blockquote><p>　　function Cat(name,color){</p><br><p>return {</p><br><p>name:name,</p><br><p>color:color</p><br><p>}</p><br><p>}</p></blockquote><br><p>然后生成实例对象，就等于是在调用函数：</p><br><blockquote><p>　　var cat1 = Cat(“大毛”,”黄色”);</p><br><p>var cat2 = Cat(“二毛”,”黑色”);</p></blockquote><br><p>这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p><br><p><strong>三、 构造函数模式</strong></p><br><p>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。</p><br><p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank">this变量</a>。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</p><br><p>比如，猫的原型对象现在可以这样写，</p><br><blockquote><p>　　function Cat(name,color){</p><br><p>this.name=name;</p><br><p>this.color=color;</p><br><p>}</p></blockquote><br><p>我们现在就可以生成实例对象了。</p><br><blockquote><p>　　var cat1 = new Cat(“大毛”,”黄色”);</p><br><p>var cat2 = new Cat(“二毛”,”黑色”);</p><br><p>alert(cat1.name); // 大毛</p><br><p>alert(cat1.color); // 黄色</p></blockquote><br><p>这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。</p><br><blockquote><p>　　alert(cat1.constructor == Cat); //true</p><br><p>alert(cat2.constructor == Cat); //true</p></blockquote><br><p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p><br><blockquote><p>　　alert(cat1 instanceof Cat); //true</p><br><p>alert(cat2 instanceof Cat); //true</p></blockquote><br><p><strong>四、构造函数模式的问题</strong></p><br><p>构造函数方法很好用，但是存在一个浪费内存的问题。</p><br><p>请看，我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：</p><br><blockquote><p>　　function Cat(name,color){</p><br><p>this.name = name;</p><br><p>this.color = color;</p><br><p>this.type = “猫科动物”;</p><br><p>this.eat = function(){alert(“吃老鼠”);};</p><br><p>}</p></blockquote><br><p>还是采用同样的方法，生成实例：</p><br><blockquote><p>　　var cat1 = new Cat(“大毛”,”黄色”);</p><br><p>var cat2 = new Cat (“二毛”,”黑色”);</p><br><p>alert(cat1.type); // 猫科动物</p><br><p>cat1.eat(); // 吃老鼠</p></blockquote><br><p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p><br><blockquote><p>　　alert(cat1.eat == cat2.eat); //false</p></blockquote><br><p>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p><br><p><strong>五、 Prototype模式</strong></p><br><p>Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p><br><p>这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p><br><blockquote><p>　　function Cat(name,color){</p><br><p>this.name = name;</p><br><p>this.color = color;</p><br><p>}</p><br><p>Cat.prototype.type = “猫科动物”;</p><br><p>Cat.prototype.eat = function(){alert(“吃老鼠”)};</p></blockquote><br><p>然后，生成实例。</p><br><blockquote><p>　　var cat1 = new Cat(“大毛”,”黄色”);</p><br><p>var cat2 = new Cat(“二毛”,”黑色”);</p><br><p>alert(cat1.type); // 猫科动物</p><br><p>cat1.eat(); // 吃老鼠</p></blockquote><br><p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</p><br><blockquote><p>　　alert(cat1.eat == cat2.eat); //true</p></blockquote><br><p><strong>六、 Prototype模式的验证方法</strong></p><br><p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p><br><p><strong>6.1 isPrototypeOf()</strong></p><br><p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p><br><blockquote><p>　　alert(Cat.prototype.isPrototypeOf(cat1)); //true</p><br><p>alert(Cat.prototype.isPrototypeOf(cat2)); //true</p></blockquote><br><p><strong>6.2 hasOwnProperty()</strong></p><br><p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。</p><br><blockquote><p>　　alert(cat1.hasOwnProperty(“name”)); // true</p><br><p>alert(cat1.hasOwnProperty(“type”)); // false</p></blockquote><br><p><strong>6.3 in运算符</strong></p><br><p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p><br><blockquote><p>　　alert(“name” in cat1); // true</p><br><p>alert(“type” in cat1); // true</p></blockquote><br><p>in运算符还可以用来遍历某个对象的所有属性。</p><br><blockquote><p>　　for(var prop in cat1) { alert(“cat1[“+prop+”]=”+cat1[prop]); }</p></blockquote><br><p>未完，请继续阅读这个系列的第二部分<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank">《构造函数的继承》</a>和第三部分<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank">《非构造函数的继承》</a>。</p><br><p>（完）</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-202ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/202ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/202ver/">【转】JavaScript基础之对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转自<a href="http://www.cnblogs.com/syuko/archive/2008/03/05/1091843.html" target="_blank" rel="external">http://www.cnblogs.com/syuko/archive/2008/03/05/1091843.html</a></p><br><p>JavaScript基础之对象</p><br><p>从2004年下半年开始学习Web编程至今3年有余。从HTML，asp开始到现在的VS2008一路学过来，其中学的最多的还是服务器端编程，对客户端编程的学习还是不成系统。虽然在很多个系统里面应用过脚本，有些还起到了比较重要的作用。但一直是只知其然不知其所以然，用的是小心翼翼。现在脚本编程从以前的”雕虫小技”变成了一个Web开发不可或缺的元素，其地位大大提高了，特别是Ajax兴起之后它更是”炙手可热”了。鉴于此种情况及自己对脚本编程的热爱，于是就系统地学习一下脚本。</p><br><p>学习是理解和记忆的过程。在理解和记忆的过程中必不可少地就需要一些辅助的记录，于是我就将自己的学习记录写成随笔。一来是帮助自己理解和记忆，二来也给其它热爱脚本的同志一些参考。</p><br><p>1 JavaScript对象</p><br><p>ECMA-262将对象（object）定义为”属性的无序集合，每个属性存放一个原始值、对象或函数”（unordered collection of properties each of which contains a primitive value, object, or function）。这意味着对象是无特定顺序的值的数组。在ECMAScript中，对象由特性（Attribute）构成，特性可以是原始值，也可以是引用值。如果特性存放的是函数，它将被看作对象的方法（Method），否则该特性被看作属性（Property）。</p><br><p>2 对象的废除</p><br><p>ECMAScript有无用存储单元收集程序（就像C#的垃圾收集器），意味着不必专门销毁对象来释放内存。当再没有对对象的引用时，该对象就被废除了。运行无用存储单元收集程序时，所有废除的对象都会被销毁。每当函数执行完它的代码，无用存储单元收集程序都会运行，释放所有的局部变量，还有在一些其它不可预知的情况下，无用存储单元收集程序也会运行。<br><br>把对象的所有引用都设置为null，可以强制性的废除对象。例如：</p><br><p>Var oObject=new Object();</p><br><p>// 程序逻辑</p><br><p>oObject=null;</p><br><p>当变量oObject设置为null后，对第一个创建的对象的引用就不存在了。这意味着下次运行无用存储单元收集程序时，该对象将被销毁。<br><br>每用完一个对象后，就将其废除，来释放内存，这是个好习惯。这样还确保不再使用已经不能访问的对象，从而防止程序设计错误的出现。此外，旧的浏览器（如IE）没有完全的无用存储单元收集程序，所以卸载页面时，对象可能不能被正确地销毁。以前IE6就有这样的诟病，当页面被关闭后对象还是没有被释放，所以总是会导致内存溢出的错误。废除对象和它所有的特性是确保内存正确使用的最好方法。</p><br><p>3 对象的类型</p><br><p>JavaScript中对象分为：本地对象（native object）、内置对象（built-in object）、宿主对象（host object）。其中本地对象和宿主对象大家一般用的比较多，比较熟。这里我就重点说明一下内置对象。<br><br>ECMA-262把内置对象定义为”由ECMAScript实现提供的、独立于宿主环境的所有对象，在ECMAScript程序开始执行时出现”（any object supplied by an ECMAScript implementation, independent of the host environment, which is present at the start of the execution of an ECMAScript program.）。这意味着开发者不必明确实例化内置对象，它已经被实例化了。但ECMAScript只定义了两个内置对象：</p><br><p>3.1 Math对象</p><br><p>Math对象就是解决数学问题的所有公式。这个在各种编程语言中都有类似的实现，就不做介绍了。</p><br><p>3.2 Global对象</p><br><p>园子里很多搞ASP.net的，相信大家对其中的Global.asax非常熟悉了。但这个对象在ECMAScript中却比较特殊。因为它实际上根本就不存在。如果尝试编写下面的代码去实例化它，将得到错误：<br><br>Var _global=new Global();<br><br>错误消息显示Global不是对象，但上文却说Global是一个内置对象，这不就自相矛盾了吗？不矛盾。这里需要理解的主要概念是，在ECMAScript中，不存在独立的函数，所有的函数都必须是某个对象的方法。ECMAScript中常用的函数例如isNaN()、isFinite（）等，看起来都像独立的函数。实际上，它们都是Global对象的方法。而且Global对象的方法还不止这些。</p><br><p>4 定义类或对象</p><br><p>虽然ECMAScript越来越正规化了，但创建对象的方法却被置之不理。在高级的编程语言（如C#）中，创建对象的方法被明确的定义了。所以不会有太大的分歧。但在脚本语言中创建对象的方法就是多种多样了。</p><br><p>4.1 工厂方式</p><br><p>由于对象的属性可在对象创建后动态定义，所以许多开发者都在初次引入JavaScript时编写类似下面的代码：<br><br>Var oCar=new Object();<br><br>oCar.color=”red”;<br><br>oCar.doors=4;<br><br>oCar.mpg=23;<br><br>oCar.showColor=function(){alert(this.color);};<br><br>在这段代码中，创建对象car。然后给它设置几个属性：它的颜色是红色，有四个门，每加仑油23英里。最后一个属性是指向函数的指针，意味着该属性其实是个方法。执行这段代码后，就可以使用对象car了。可是要创建多个car实例就麻烦了。<br><br>要解决此问题，开发者可以创建并返回特定类型的对象的工厂函数。例如，函数CreateCar（）可用于封装前面列出的创建car对象的操作：<br><br>Function createCar()<br><br>{<br><br>Var oTempCar=new Object();<br><br>oTempCar.color=”red”;<br><br>oTempCar.doors=4;<br><br>oTempCar.mpg=23;<br><br>oTempCar.showColor=function(){alert(this.color)};</p><br><p>return oTempCar;<br><br>}</p><br><p>Var oCar1=createCar();<br><br>Var oCar2=createCar();</p><br><p>这里，前面的所有代码都包含在createCar()函数中，此外还有一行额外的代码，返回Car对象作为函数值。调用此函数时，将创建新对象，并赋予它所有必要的属性，复制出一个前面说明的car对象。使用该方法，可以容易地创建car对象的两个版本，他们的属性完全一样。当然，还可以修改creatCar（）函数，给它传递各个属性的默认值，而不是赋予属性默认值：<br><br>Function createCar(sColor,iDoors,iMpg)<br><br>{<br><br>Var oTempCar=new Object();<br><br>oTempCar.color= sColor;<br><br>oTempCar.doors= iDoors;<br><br>oTempCar.mpg= iMpg;<br><br>oTempCar.showColor=function(){alert(this.color)};</p><br><p>return oTempCar;<br><br>}</p><br><p>Var oCar1=createCar(“red”,4,23);<br><br>Var oCar2=createCar(“blue”,2,26);<br><br>oCar1.showColor();            // 输出”red”<br><br>oCar2.showColor();            // 输出”blue”</p><br><p>给createCar（）函数加上参数，即可为要创建的car对象的color、doors和mpg属性赋值。使这两个对象具有相同的属性，却有不同的属性值。但这里有个问题：每次调用函数createCar（），都要创建新函数showColor()，意味着每个对象都有自己的showColor（）版本。事实上，每个对象用的都是同一段代码。这样的定义方法还有一个如下的变形：<br><br>Function Car(sColor,iDoors,iMpg)<br><br>{<br><br>this.color= sColor;<br><br>this.doors= iDoors;<br><br>this.mpg= iMpg;<br><br>this.showColor=function(){alert(this.color)};<br><br>}</p><br><p>Var oCar1=new Car(“red”,4,23);<br><br>Var oCar2=new Car(“blue”,2,26);</p><br><p>oCar1.showColor();            // 输出”red”<br><br>oCar2.showColor();            // 输出”blue”<br><br>这个方法和上一个方法有个一样的缺陷：重复的创建了showColor()函数。为了解决这个缺陷我们可以用下面的方法。</p><br><p>4.2 原型方式</p><br><p>该方法利用了对象的Prototype属性。用空构造函数来设置类名，然后所有的属性和方法都被直接赋予prototype属性：<br><br>Function Car()<br><br>{}</p><br><p>Car.prototype.color=”red”;<br><br>Car.prototype.doors=4;<br><br>Car.prototype.mpg=23;<br><br>Car.prototype.showColor=function(){alert(this.color)};</p><br><p>Var oCar1=new Car();<br><br>Var oCar2=new Car();</p><br><p>使用这个方法可以解决重复创建showColor（）函数，但又会有新的问题，考虑下面的例子：</p><br><p>Function Car()<br><br>{}</p><br><p>Car.prototype.color=”red”;<br><br>Car.prototype.doors=4;<br><br>Car.prototype.mpg=23;<br><br>Car.prototype.drivers=new Array(“Mike”,”Sue”);<br><br>Car.prototype.showColor=function(){alert(this.color)};</p><br><p>Var oCar1=new Car();<br><br>Var oCar2=new Car();</p><br><p>oCar1.drivers.push(“Matt”);</p><br><p>alert(oCar1.drivers);        // 输出”Mike,Sue,Matt”<br><br>alert(oCar2.drivers);        // 输出”Mike,Sue,Matt”</p><br><p>这里，属性drivers是指向Array对象的指针。改变指针指向的内容，所有的实例都会改变。看来这种方法也不可取</p><br><p>4.3 混合方式</p><br><p>这种方式就是用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果所有的函数只创建一次，而每个对象都具有自己的对象属性实例。<br><br>Function Car(sColor,iDoors,iMpg)<br><br>{<br><br>this.color= sColor;<br><br>this.doors= iDoors;</p><br><p>this.mpg= iMpg;<br><br>Car.drivers=new Array(“Mike”,”Sue”);<br><br>}</p><br><p>Car.prototype.showColor=function(){alert(this.color)};</p><br><p>Var oCar1=new Car(“red”,4,23);<br><br>Var oCar2=new Car(“blue”,3,25);</p><br><p>oCar1.drivers.push(“Matt”);</p><br><p>alert(oCar1.drivers);        // 输出”Mike,Sue,Matt”<br><br>alert(oCar2.drivers);        // 输出”Mike,Sue”</p><br><p>这种方式是ECMAScript主要采用的方式，它具有其他方式的特性，却没有它们的缺陷。在实际编程中应用的也是最多了。<br><br>另外还有JSON创建方式。其创建的方式如下：</p><br><p>var Car =<br><br>{<br><br>color: “red”,<br><br>doors: 4,<br><br>mpg: 23,<br><br>drivers: [{name: “Mike”, age: 20, Married: false}, {name: “Sue”, age: 30, Marred: true}],<br><br>showColor: function() {alert(this.color)}<br><br>};<br><br>这种创建对象的方式也比较优雅。可作为Ajax返回的文本，然后用eval()函数将其还原成一个对象。著名的脚本框架JQuery就有专门接收返回文本为JSON对象的异步方法。</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-203ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/203ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/203ver/">【转】领悟 JavaScript 中的面向对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转自<a href="http://www.iteye.com/topic/155109" target="_blank" rel="external">http://www.iteye.com/topic/155109</a></p><br><p>领悟 JavaScript 中的面向对象</p><br><p>&nbsp;</p><br><p>注：读完本文后请务必接着看完所有回复！</p><br><p>JavaScript 是面向对象的。但是不少人对这一点理解得并不全面。</p><br><p>在 JavaScript 中，对象分为两种。一种可以称为“普通对象”，就是我们所普遍理解的那些：数字、日期、用户自定义的对象（如：{}）等等。</p><br><p>还有一种，称为“方法对象”，就是我们通常定义的 function。你可能觉得奇怪：方法就是方法，怎么成了对象了？但是在 JavaScript 中，方法的确是被当成对象来处理的。下面是一个简单的例子：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li><span class="keyword">function</span> func() {alert(<span class="string">‘Hello!’</span>);}</li><br><li>alert(func.toString());</li><br></ol><br></div><br><p>在这个例子中，func 虽然是作为一个方法定义的，但它自身却包含一个 toString 方法，说明 func 在这里是被当成一个对象来处理的。更准确的说，func 是一个“方法对象”。下面是例子的继续：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li>func.name = “I am func.”;</li><br><li>alert(func.name);</li><br></ol><br></div><br><p>我们可以任意的为 func 设置属性，这更加证明了 func 就是一个对象。那么方法对象和普通对象的区别在哪里呢？首先方法对象当然是可以执行的，在它后面加上一对括号，就是执行这个方法对象了。</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li>func();</li><br></ol><br></div><br><p>所以，方法对象具有二重性。一方面它可以被执行，另一方面它完全可以被当成一个普通对象来使用。这意味着什么呢？这意味着方法对象是可以完全独立于其他对象存在的。这一点我们可以同 Java 比较一下。在 Java 中，方法必须在某一个类中定义，而不能单独存在。而 JavaScript 中就不需要。</p><br><p>方法对象独立于其他方法，就意味着它能够被任意的引用和传递。下面是一个例子：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li><span class="keyword">function</span> invoke(f) {</li><br><li>    f();</li><br><li>}</li><br><li>invoke(func);</li><br></ol><br></div><br><p>将一个方法对象 func 传递给另一个方法对象 invoke，让后者在适当的时候执行 func。这就是所谓的“回调”了。另外，方法对象的这种特殊性，也使得 this 关键字不容易把握。这方面相关文章不少，这里不赘述了。</p><br><p>除了可以被执行以外，方法对象还有一个特殊的功用，就是它可以通过 new 关键字来创建普通对象。</p><br><p>话说每一个方法对象被创建时，都会自动的拥有一个叫 prototype 的属性。这个属性并无什么特别之处，它和其他的属性一样可以访问，可以赋值。不过当我们用 new 关键字来创建一个对象的时候，prototype 就起作用了：它的值（也是一个对象）所包含的所有属性，都会被复制到新创建的那个对象上去。下面是一个例子：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li>func.prototype.name=”prototype of func”;</li><br><li><span class="keyword">var</span> f = <span class="keyword">new</span> func();</li><br><li>alert(f.name);</li><br></ol><br></div><br><p>执行的过程中会弹出两个对话框，后一个对话框表示 f 这个新建的对象从 func.prototype 那里拷贝了 name 属性。而前一个对话框则表示 func 被作为方法执行了一遍。你可能会问了，为什么这个时候要还把 func 执行一遍呢？其实这个时候执行 func，就是起“构造函数”的作用。为了形象的说明，我们重新来一遍：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li><span class="keyword">function</span> func() {</li><br><li>    <span class="keyword">this</span>.name=”name has been changed.”</li><br><li>}</li><br><li>func.prototype.name=”prototype of func”;</li><br><li><span class="keyword">var</span> f = <span class="keyword">new</span> func();</li><br><li>alert(f.name);</li><br></ol><br></div><br><p>你就会发现 f 的 name 属性不再是”prototype of func”，而是被替换成了”name has been changed”。这就是 func 这个对象方法所起到的“构造函数”的作用。所以，在 JavaScript 中，用 new 关键字创建对象是执行了下面三个步骤的：</p><br><ol><br><li>创建一个新的普通对象；</li><br><li>将方法对象的 prototype 属性的所有属性复制到新的普通对象中去。</li><br><li>以新的普通对象作为上下文来执行方法对象。</li><br></ol><br><p>对于“new func()”这样的语句，可以描述为“从 func 创建一个新对象”。总之，prototype 这个属性的唯一特殊之处，就是在创建新对象的时候了。<br><br>那么我们就可以利用这一点。比如有两个方法对象 A 和 B，既然从 A 创建的新对象包含了所有 A.prototype 的属性，那么我将它赋给 B.prototype，那么从 B 创建的新对象不也有同样的属性了？写成代码就是这样：</p><br><p>&nbsp;</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li>A.prototype.hello = <span class="keyword">function</span>(){alert(<span class="string">‘Hello!’</span>);}</li><br><li>B.prototype = <span class="keyword">new</span> A();</li><br><li><span class="keyword">new</span> B().hello();</li><br></ol><br></div><br><p>这就是 JavaScript 的所谓“继承”了，其实质就是属性的拷贝，这里利用了 prototype 来实现。如果不用 prototype，那就用循环了，效果是一样的。所谓“多重继承”，自然就是到处拷贝了。</p><br><p>JavaScript 中面向对象的原理，就是上面这些了。自始至终我都没提到“类”的概念，因为 JavaScript 本来就没有“类”这个东西。面向对象可以没有类吗？当然可以。先有类，然后再有对象，这本来就不合理，因为类本来是从对象中归纳出来的，先有对象再有类，这才合理。像下面这样的：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li><span class="keyword">var</span> o = {}; <span class="comment">// 我发现了一个东西。</span></li><br><li>o.eat = <span class="keyword">function</span>(){<span class="keyword">return</span> <span class="string">“I am eating.”</span>}  <span class="comment">// 我发现它会吃；</span></li><br><li>o.sleep = <span class="keyword">function</span>(){<span class="keyword">return</span> <span class="string">“ZZZzzz…”</span>}  <span class="comment">// 我发现它会睡；</span></li><br><li>o.talk = <span class="keyword">function</span>(){<span class="keyword">return</span> <span class="string">“Hi!”</span>} <span class="comment">// 我发现它会说话；</span></li><br><li>o.think = <span class="keyword">function</span>(){<span class="keyword">return</span> <span class="string">“Hmmm…”</span>} <span class="comment">// 我发现它还会思考。</span></li><br><li></li><br><li><span class="keyword">var</span> Human = <span class="keyword">new</span> Function(); <span class="comment">// 我决定给它起名叫“人”。</span></li><br><li>Human.prototype = o; <span class="comment">// 这个东西就代表了所有“人”的概念。</span></li><br><li></li><br><li><span class="keyword">var</span> h = <span class="keyword">new</span> Human(); <span class="comment">// 当我发现其他同它一样的东西，</span></li><br><li>alert(h.talk()) <span class="comment">// 我就知道它也是“人”了！</span></li><br></ol><br></div><br><p>&nbsp;</p><br><p>&nbsp;</p><br><p>————————————————————————————————<br><br>文章出自 yiding-he.iteye.com，转载请注明作者和出处。</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-204ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/204ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/204ver/">JavaScript-call:简单理解call</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>理解转自<a href="http://www.jb51.net/article/22963.htm" target="_blank" rel="external">http://www.jb51.net/article/22963.htm</a></p><br><pre class="lang:default decode:true ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-apply与call&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>    function num1(a,b){<br>        alert(a+b);<br>    }<br>    function num2(a,b){<br>        alert(“a<em>b:”+a</em>b);<br>    }<br>    num2.call(num1,10,20)//这个例子中的意思就是用 num2 来替换 num1，num2.call(num1,10,20) == num2(10,20) ，所以运行结果为：alert(200); // 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。<br><br>    function abb(name){<br>        this.name=name<br>        this.showName=function(){alert(“abb name:”+this.name)}<br>    }<br>    function ann(name){<br>        this.name=name<br>    }<br><br>    var abb1=new abb(“abb1的name”);<br>    var ann1=new ann(“ann的name”);<br><br>    abb1.showName.call(ann1);//首先 ann是没有showName函数 但是我们又让ann1来执行showName函数,于是通过call继承下来了<br>    //showName=function(){alert(“abb name”+this.name)} 这里的this.name指的是 ann的name<br><br>    //以下解释来自<a href="http://www.jb51.net/article/22963.htm" target="_blank" rel="external">http://www.jb51.net/article/22963.htm</a><br>    //注意，call 的意思是把 abb1 的方法放到ann1上执行，原来ann1是没有showName() 方法，现在是把abb1 的showName()方法放到 ann 上来执行，所以this.name 应该是 ann，执行的结果就是 ：alert（”ann name”）;<br>//  怎么样，觉得有意思了吧，可以让a对象来执行b对象的方法，这是java程序员所不敢想的。还有更有趣的，可以用 call 来实现继承<br><br>    function Class1() {<br>        this.showTxt = function(txt) {<br>            alert(txt);<br>        }<br>    }<br><br>    function Class2() {<br>        Class1.call(this);<br>    }<br>    var c2 = new Class2();<br>    c2.showTxt(“cc”);<br>    //这样 Class2 就继承Class1了，Class1.call(this) 的 意思就是使用 Class1 对象代替this对象，那么 Class2 中不就有Class1 的所有属性和方法了吗，c2 对象就能够直接调用Class1 的方法以及属性了，执行结果就是：alert（“cc”）;<br>    function Class10() {<br>        this.showSub = function(a, b) {<br>            alert(a - b);<br>        }<br>    }<br><br>    function Class11() {<br>        this.showAdd = function(a, b) {<br>            alert(a + b);<br>        }<br>    }<br><br>    function Class3() {<br>        Class10.call(this);<br>        Class11.call(this);<br>    }<br>    var c3 =new Class3();<br>    c3.showAdd(10,20)<br><br>    //apply与call区别在于 call 的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments<br><br><br><br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-206ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/206ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/206ver/">JavaScript:节点-2:再次理解下节点</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本来想写详细点,发现自己理解还不够 先放着 以后再填</p><br><pre class="lang:default decode:true ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-再次理解childNodes&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>        function knowChildnodes(){<br>            var get_childnodes=document.body.childNodes;<br>            console.log(get_childnodes);//当前页面有多少元素<br>            var get_childnodes0=document.body.childNodes[0];<br>            console.log(get_childnodes0);//第0个的元素是什么<br>            var get_did=document.getElementById(“did”);//获取div<br>            console.log(get_did.childNodes);//输出div下的元素<br>            console.log(get_did.childNodes[1].nodeName);//从控制台可以看到[0]是一个#text文本 [1]才是元素<br>            console.log(get_did.firstChild.nodeName);//也可以使用firstChild获取到第一个[0]元素的名字<br>            console.log(get_did.childNodes.length.nodeName);//这样是找不到的 因为在childNodes是从0开始 获取到最后一个元素可以使用<br>            console.log(get_did.childNodes[get_did.childNodes.length-2].nodeName)//获取到最后一个元素属性名字 -1是#text文本<br>            console.log(get_did.lastChild.nodeName)//获取到最后一个元素的名字<br><br><br>            //兄弟节点,父级节点<br>            console.log(“我是分隔符,下面开始兄弟节点 父级节点”);<br>            console.log(“第0个元素是#text 那么他的下一个元素应该是p||”+get_did.childNodes[0].nextSibling.nodeName);//<br>            console.log(“第1个元素是p,那么他的下一个元素应该是p的文本||”+get_did.childNodes[1].nextSibling.nodeName);//<br>            console.log(“第2个元素是p的文本 那么他的下一个元素应该是p||”+get_did.childNodes[2].nextSibling.nodeName);<br>            //以上是下级的结构 那么同级的结构是什么呢？<br>            var get_h1=document.getElementsByTagName(“h1”);<br>            console.log(get_h1[0].nextSibling.nodeValue);//文本节点…值是回车符<br>            //坑待理解后再填<br><br>        }<br><br><br>        window.onload=function(){<br>            knowChildnodes();<br>        }<br><br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;hello&lt;/h1&gt;<br>    &lt;div id=”did”&gt;<br>        &lt;p&gt;我是soul&lt;/p&gt;<br>        &lt;p&gt;灵魂追逐者&lt;/p&gt;<br>        &lt;p&gt;放荡的灵魂&lt;/p&gt;<br>    &lt;/div&gt;<br>    &lt;h1&gt;第二个soul&lt;h1&gt;<br>    &lt;p&gt;我是规则之外的灵魂&lt;/p&gt;<br>    &lt;p&gt;我是规则之外的灵魂&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-207ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/207ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/207ver/">JavaScript-简单动画5:闪瞎你狗眼的打字机</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一个很简单的打字机..本来想自己不去百度写一个打字机的..但是技术还是不够啊..所以就去网上看了一下 然后理解了思路 自己写了一个出来</p><br><pre class="lang:default decode:true  ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-打字机&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>    //思路<br>    //每1秒打一个字,每打一个字更改一下颜色<br>    //1.创建一个P元素<br>    //2.创建一个动画.<br>    //2.5 创建一个文本数组<br>    //3.创建一个颜色数组<br>    //4.把颜色数组应用到文本上<br>    var new_p =document.createElement(“p”);//全局函数 意思是新建一个标签p<br>    var txt=”hello soul next fllow myeles night die”;//创建一个文本数组<br>    var i=0,n=0;//设置i=0,,n=0<br>    var color_1=[“bule”,”green”,”red”,”rgb(100,200,300)”,”black”]//创建一个颜色数组<br>    function test(){//开始打字+闪瞎你狗眼<br>        var p_txt =document.createTextNode(txt.charAt(i));//创建一个文本节点,文本节点内容等于文本数组的第[i]个元素<br>        i++;//i++<br>        new_p.appendChild(p_txt);//在p标签下添加文本节点<br>        new_p.style.color=color_1[n];//设置p标签的颜色等于颜色数组的第[n]个元素颜色<br>        n++;//n++<br>        document.body.appendChild(new_p);//在文档根目录添加p<br>        var anmi=setTimeout(test,500);//每500毫秒执行test函数<br>        if(n==color_1.length){//如果n等于颜色数组的长度<br>            n=0;//重新开始计数<br><br>        }<br>        if(i==txt.length){//如果i等于文本数组的长度<br>            clearTimeout(anmi);//停止动画<br><br>        }<br><br>    }<br><br>    window.onload=function(){<br>        test()<br>    }<br><br><br><br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-208ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/208ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/208ver/">JavaScript-内置对象-2:数组的内置对象是shenmegui?</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本章介绍了数组内置对象的以下内置对象,可以复制代码保存到本地文件后观看哦</p><br><blockquote><br><ol><br><li>数组对象之长度对象</li><br><li>转换数组为字符串</li><br><li>数组的元素插入</li><br><li>数组之排序</li><br><li>数组之 相加</li><br><li>数组之 插入 替换 删除</li><br><li>数组之 位置</li><br><li>数组之迭代方法</li><br><li>归并数组</li><br></ol><br></blockquote><br><pre class="lang:default decode:true ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-内置对象-2&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>    function soulArr(){<br>        //数组对象<br><br>        //数组对象之长度对象<br>        var soul_arr1=[“hello”,”soul”,”i\’m”,”soul seeker”]//这里使用了转义字符\’<br>        console.log(“soul_arr1长度是多少”+soul_arr1.length);//soul_arr1有四个元素输出4<br>        soul_arr1.length=3;//设置长度会删除后面的元素<br>        console.log(“设置长度是3,删除了最后一个长度,那么现在数组内容是:”+soul_arr1);<br>        soul_arr1[5]=”new soul”;<br>        console.log(“新增加了一个元素,那么现在数组内容是:”+soul_arr1);//hello,soul,i’m,,,new soul  中间多出了两个逗号 是因为我们在上次设置了长度为3 然后我们又在第5个添加了元素, 所以中间没有值要写逗号<br><br>        soul_arr2=[“hello”,”soul”];<br>        soul_arr2[soul_arr2.length]=”seeker”;<br>        console.log(“在数组最后添加一个元素”+soul_arr2);<br>        soul_arr2[soul_arr2.length-1]=”new seeker”//更改数组最后一个元素内容 为什么是-1 因为长度是2 但是数组从0开始 所以要-1<br>        console.log(“更改数组最后一个元素内容”+soul_arr2);<br><br>        //转换数组为字符串<br>        console.log(“转换数组为字符串”+soul_arr2.toString());<br>        console.log(“使用不同的符号来作为数组转为字符串的分隔符”+soul_arr2.join(“||”));<br><br>        //数组的元素插|入<br>        var soul_arr3=[“hello”];<br>        soul_arr3.push(“soul”,”seeker”);<br>        soul_arr3[3]=”new soul”;//稍微理解一下 数组是从0开始0,1,2(在最后添加了两个元素),[3]就是第4个元素<br>        console.log(“在数组的最后添加元素”+soul_arr3);<br>        soul_arr3.pop()<br>        console.log(“移除了最后一个元素”+soul_arr3);<br>        var fsoul_arr3=soul_arr3.shift();//取得数组的第一项并且删除第一项<br>        console.log(“数组取出的第一项是:”+fsoul_arr3+”|现在数组内容为:”+soul_arr3);<br>        var f1soul_arr3=soul_arr3.shift();//再取出第一项<br>        console.log(“数组取出的第一项是:”+f1soul_arr3+”|现在数组内容为:”+soul_arr3);<br>        soul_arr3.push(“new seeker”,”new shenshi”,”new hello”);//添加几个元素<br>        var nsoul_arr3=soul_arr3.unshift(“ok”,”yes”);<br>        console.log(“在数组前端推入两项 内容是:”+nsoul_arr3+”|当前数组内容为:”+soul_arr3);<br><br>        //数组之排序<br>        var soul_arr4=[“b”,”a”,”d”,”c”];<br>        soul_arr4.sort();//从低到高排序<br>        console.log(“从低到高排序”+soul_arr4);<br>        soul_arr4.reverse();//翻转数组排序<br>        console.log(“翻转数组排序”+soul_arr4);<br>        //sort排序有一个问题 在进行比较时 因为9位于15前面 所以会把9放后面<br>        //…下文数组不是排序好的嘛..为何还要多此一举<br>        var soul_arr5 =[5,9,15,20,25];<br>        soul_arr5.sort();<br>        console.log(“排序正确的数组再进行排序:”+soul_arr5);<br>        //怎么解决呢？编写了一个函数来判断<br>        soul_arr5.sort(compaer);//利用 -1 1 0就解决了<br>        console.log(“解决后:”+soul_arr5);//从低到高<br><br>        //数组之 相加<br>        var soul_arr6=[“hello”,”world”];<br>        var soul_arr7=[“none”];<br>        soul_arr6 += soul_arr7;//直接相加会发现会把数组转换为字符串再进行相加<br>        console.log(“直接相加”+soul_arr6+”类型”+typeof soul_arr6);<br><br>        var soul_arr6=[“我是一”,”我是二”,”我是三”,”我是四”];<br>        var soul_arr7=[“我是六”,”我是七”];<br>        var soul_arr8=soul_arr6.concat(soul_arr7);//相当于复制了一份 然后再在数组末尾插入soul_arr7 不会破坏原来的数组<br>        console.log(“在数组末尾插入一个数组”+soul_arr8);<br>        //数组之 插入 替换 删除<br>        //删除<br>        var soul_arr9=[“我是0”,”我是1”,”我是2”,”我是3”,”我是4”];<br>        var del_soul_arr9=soul_arr9.splice(0,2);//删除第一项与第二项 0与2之间不就是第一项和第二项嘛？<br>        console.log(“删除的数组为:”+del_soul_arr9+”当前数组内容为:”+soul_arr9);<br>        //插入<br>        var add_soul_arr9=soul_arr9.splice(2,0,”我是在\’我是4\’之前插入的”,”再插入一个”);//从第二项插入,因为上面删除了两项 所以第二项应该是”我是4”<br>        console.log(“插入的元素为:”+add_soul_arr9+”|当前数组内容为:”+soul_arr9);<br>        //替换<br>        var soul_arr10=[“我是0”,”我是1”,”我是2”,”我是3”,”我是4”];<br>        var rep_soul_arr10=soul_arr10.splice(0,1,”我是插入的”,”我是插入的-2”);<br>        console.log(“删除的元素为:”+rep_soul_arr10+”|当前数组内容:”+soul_arr10);//替换”我是0”后再插入一个元素<br><br>        //数组之 位置<br>        //从正向开始查找<br>        var soul_arr10=[“1”,4,”1”,1,2,3,”1”];<br>        console.log(“正向查找:”+soul_arr10.indexOf(“1”));//indexOf查找时会使用全等查找 并且查到到了后会输出元素在数组的位置<br>        //反向查找<br>        console.log(“反向查找:”+soul_arr10.lastIndexOf(“1”));//反向查找会查找到最远的那个<br>        //还有分段查询<br>        console.log(“从1开始查询而非0(数组第一个元素)”+soul_arr10.indexOf(“1”,1));//结果是2<br>        console.log(“从反向的6开始查询而非反向的0|”+soul_arr10.lastIndexOf(“1”,6))//结果是6<br><br>        //数组之迭代方法<br>        var soul_arr11=[1,2,3,4,5,6,7];<br>        //将大于5的元素组成数组<br>        var soul5_arr11=soul_arr11.filter(function(num){<br>            return(num&gt;5);<br>        })<br>        console.log(“新组成数组:”+soul5_arr11+”|原来的数组”+soul_arr11);//发现不会影响到原来的数组<br>        //将每个数组乘以2<br>        var soul2_arr11=soul_arr11.map(function(num){<br>            return(num*2);<br>        })<br>        console.log(“乘以后的数组:”+soul2_arr11);<br><br>        //归并数组<br>        //数组内容进行相加<br>        var soul_arr12=soul_arr11.reduce(function(q,h){//reduce是从正向开始相加 也可以从反向开始<br>            return(q+h);<br>        })//传递两个参数 q是前一个值,h是当前值<br>        console.log(“相加结果:”+soul_arr12);<br>        var soul_arr13=soul_arr11.reduceRight(function(q,h){<br>            return(q+h);<br>        })<br>        console.log(“反向相加,因为是简单相加所以都一样”+soul_arr13);<br><br><br>    }<br>    function compaer(a,b){<br>        if(a&gt;b){//比较两个值 如果前面的大于后面的<br>            return 1;//把后面的放前面 所以返回1<br><br>        }<br>        if(a&lt;b){//比较两个值 如果前面的小于后面的<br>            return -1;//把前面的放后面 返回-1<br><br>        }<br>        if(a=b){//如果相等<br>            return 0;//不做更改<br>        }<br>    }<br><br><br><br><br>    window.onload=function(){<br>        soulArr();<br><br>    }<br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-209ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/209ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/209ver/">JavaScript-内置对象-1:我们中出了一个对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>FBI WANNING！ 本文章包含以下内容</p><br><blockquote><br><ol><br><li>字符串对象</li><br><li>日期对象</li><br><li>日期小动画</li><br></ol><br></blockquote><br><pre class="lang:default decode:true ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-对象-1&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>        function soulObject(){<br>            //对象<br>            var soul =new Object();//创建了一个对象 名字是soul<br>            soul.name=”灵魂”;<br>            soul.height =”保密”;<br>            //对象字面量创建一个对象<br>            var soul_1 ={<br>                sex:”你猜”,//用逗号分隔<br>                “love”:”不是你就对了”,//对象名还可以是字符串<br>                age:”永远19岁”<br>            }<br><br>            console.log(“输出soul对象的name属性是:”+soul.name+”输出sou_1.sex对象:”+soul_1.sex+”输出soul_1.\’love\’对象:”+soul_1.love);<br>            var soul_1age=”age”;//注意记得加引号<br>            console.log(“通过方括号法来输出soul_1.age:”+soul_1[soul_1age]);<br><br><br>            //字符串对象因为是内置对象 并不会影响到字符串本身<br>            var soul_2=”Hello Soul”;//字符串从0开始，空格也算一个字符<br>            console.log(“字符串长度为:”+soul_2.length+”字符串第一次出现的位置\’o\’:”+soul_2.indexOf(“o”)+”|字符串\’o\’最后一次出现的位置”+soul_2.lastIndexOf(“o”));<br>            console.log(“查找字符串并且输出”+soul_2.match(“Hello”))//如果有hello这个字符串那么就输出hello 如果没有就输出null<br>            console.log(“替换soul为soul seeker:”+soul_2.replace(“Soul”, ‘soul seeker’));<br>            console.log(“将字符串转换为大写:”+soul_2.toUpperCase()+”将字符串转换为小写:”+soul_2.toLowerCase());<br>            var soul_2arr=soul_2.split(“ “);//用空格作为分隔符<br>            console.log(“输出soul_2arr数组中第二个元素:”+soul_2arr[1]);<br>        }<br><br><br>        function soulObject1(){<br>            //Date对象<br>            var soul_date= new Date();//创建一个日期对象<br>            console.log(“当前时间是:”+soul_date+”今年是多少年:”+soul_date.getFullYear()+”获取时间的毫秒:”+soul_date.getTime());<br>            soul_date.setFullYear(2014);//设置年份为2014年<br>            console.log(soul_date);<br><br>        }<br>        function soulObject2(){<br>            //Date对象之时钟<br>            //思路<br>            //1 获取到当前时间:小时,分,秒<br>            //2为了不改变长度,给分,秒前面加上一个0<br>            //递归调用函数（动画）<br>            soul_time =new Date();<br>            var soul_time_h=soul_time.getHours();//获取小时<br>            var soul_time_m=soul_time.getMinutes();//获取分钟<br>            var soul_time_s=soul_time.getSeconds();//获取秒<br>            soul_time_m=checkMS(soul_time_m);//把个位数的分钟加上0<br>            soul_time_s=checkMS(soul_time_s);//把个位数秒加上0<br>            var p_txt=createTime();//其实获取到p元素id再写入就ok了 为什么要这么复杂呢? 因为为了复习以前的知识嘛<br>            p_txt.innerHTML=soul_time_h+”:”+soul_time_m+”:”+soul_time_s;//给p元素写入小时，分钟，秒<br>            var anmi =setTimeout(function(){//setTimeout(函数,时间)<br>                soulObject2()//递归重复调用本次函数<br>            },1000);//1000秒调用一次<br><br><br>        }<br>        function createTime(){//获取到fh属性等于show_time的p元素是哪一个<br>            var get_p=document.getElementsByTagName(“p”);<br>            for (var i = 0; i &lt; get_p.length; i++) {<br>                if(get_p[i].getAttribute(“fh”)==”show_time”){//如果fh属性等于 show_time<br>                    return get_p[i];//返回这个p元素位置<br>                }<br>            };<br><br>        }//PASS<br>        function checkMS(i){//传递一个参数<br>            if(i&lt;10){//如果这个参数小于10<br>                i=”0”+1;//i=”0”+i;<br>            }<br>            return i;//否则返回i<br>        }<br>        window.onload=function(){<br>            soulObject();<br>            soulObject1();<br>            soulObject2();<br>        }<br><br><br><br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;p fh=”show_time”&gt;&lt;/p&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-210ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/210ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/210ver/">JavaScript之console.log输出</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>console.log，顾名思义即控制台输出.什么又是控制台呢？</p><br><pre class="lang:default decode:true">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-对象-1&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>        var soul =new Object();//创建了一个对象 名字是soul<br>        soul.name=”灵魂”;<br>        soul.height =”保密”;<br>        console.log(soul.name);<br><br><br><br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>上面是一串很简单的创建对象的代码. 你可以用alert(soul.name)来输出 也可以用document.write(soul.name)来输出，</p><br><p>但是以上两个方法都没有console.log那么好使, alert一但调试的代码量多了,那么会弹很多窗口,甚至有些浏览器会在弹出好几个窗口后禁用弹出, document.write输出会有断点 每一次输出都会刷新浏览器的页面.  所以就有了console.log</p><br><p>console.log的好处需要自己体会用法跟alert是一样的.那么如何查看console.log呢？</p><br><p>按F12然后找到console就行了,上面那串代码调试的结果是</p><br><p><a href="http://7xi9fb.com1.z0.glb.clouddn.com/mm/imgs/2015-10-21-311.png" target="_blank" rel="external"><img class="alignnone wp-image-183" src="http://7xi9fb.com1.z0.glb.clouddn.com/mm/imgs/2015-10-21-311.png" data-original="http://www.old.com/wp-content/uploads/2015/03/311-1024x509.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="31" width="500" height="248"></a></p><br><p>&nbsp;</p><br><p>即可以看到console输出了</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-211ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/211ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/211ver/">JavaScript瀑布流:生活就是在挑战中度过</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>花了7天的时间把《DOM编程艺术(第二版)》看了2/3,后面的有点难度,因为前面的知识吸收还不是很好,于是转去看JavaScript高级程序设计,加深一下前面的基础知识. 昨天晚上偶然间看到brain的<a href="http://blog.brain1981.com/829.html" target="_blank" rel="external">浅谈响应式瀑布流的实现方式</a></p><br><p>发现看不懂..看的好吃力，但是生活就需要挑战嘛.于是推度娘后 在网上找到一份 JavaScript瀑布流视频版.</p><br><p>于是自己按照作者的思路,已经配合作者的代码(废话.你小子能写出来嘛？)自己写了一份.不能说是照抄.觉得最重要的还是理解了那份思路,具体的看代码哦.</p><br><p><span style="color: #993366;"><strong>HTML</strong></span></p><br><pre class="lang:default decode:true ">&lt;!doctype html&gt;<br>&lt;html lang=”cn”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-瀑布流&lt;/title&gt;<br>    &lt;script src=”app-1.js”&gt;&lt;/script&gt;<br>    &lt;link rel=”stylesheet” type=”text/css” href=”style.css”&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=”cont”&gt;<br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-1.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-2.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-3.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-4.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-5.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-6.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-7.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-8.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-9.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-10.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-1.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-2.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-3.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-4.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-5.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-6.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-7.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-8.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-9.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-10.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-1.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-2.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-3.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-4.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-5.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-6.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-7.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-8.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-9.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-10.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-1.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-2.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-3.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-4.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-5.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-6.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-7.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-8.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-9.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br><br>        &lt;div class=”box”&gt;<br>            &lt;div class=”box_img”&gt;&lt;img src=”m-10.jpg” alt=””&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br><br>    &lt;/div&gt;<br><br><br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p><strong><span style="color: #993366;"> app-1.js</span></strong></p><br><pre class="lang:default decode:true ">window.onload=function(){<br>    getCliwidth(“cont”,”box”);<br>    window.onscroll=function(){<br>        if(checkFlag()){<br>        var imgData={<br>            “data”:[<br>            {“src”:”m-3.jpg”},{“src”:”m-4.jpg”},{“src”:”m-5.jpg”},{“src”:”m-6.jpg”},{“src”:”m-7.jpg”},<br>            {“src”:”m-8.jpg”}<br>            ]<br>        };<br>        var parent=document.getElementById(“cont”);<br>        console.log(imgData.data.length);//输出imgDatajson字符串中data属性的长度<br>        for (var i = 0; i &lt; imgData.data.length; i++) {<br>            var new_box=document.createElement(“div”);<br>            new_box.className=”box”;<br>            parent.appendChild(new_box);<br>            var new_boximg=document.createElement(“div”);<br>            new_boximg.className=”box_img”;<br>            new_box.appendChild(new_boximg);<br>            var new_img =document.createElement(“img”);<br>            new_img.src=imgData.data[i].src;<br>            new_boximg.appendChild(new_img);<br><br>        };<br><br>        getCliwidth(“cont”,”box”);<br><br>        }<br>    }<br>}<br><br>//思路 盒子可以理解为图片<br>//1先获取到cont元素下面的盒子<br>//2在判断一列能够放多少个这样的盒子<br>//3然后获取到第一列当中高度最小的盒子<br>//4然后获取到第一列当中最小高度盒子的位置 也就是数组下标<br>//4.5 设置第二列图片的顶部距离为第一列盒子的最小高度<br>//5把第二列图片的居左属性设置为最小高度盒子的居左属性<br>//6然后把第一列最小盒子的高度加上第二列图片的高度<br>//滚动监听思路<br>//1获取到最后一张图片距离浏览器顶部的距离<br>//2获取滚动条距离浏览器顶部距离<br>//3获取当前页面可见的高度<br>//4如果当前页面的可见高度加上滚动条移动的像素 大于整个页面像素（也就是第一张图片距离浏览器顶部距离）<br>//循环输出思路<br>//1用json字符串来保存需要循环加载的图片src和地址<br>//2遍历json字符串data属性的长度<br>//3然后创建一个&lt;div class=”box”&gt;&lt;div class=”box_img”&gt;&lt;img src=”m-4.jpg” alt=””&gt;&lt;/div&gt;&lt;/div&gt;<br>//因为是遍历循环 所以我们创建一次就ok了<br>//4设置img src等于imgData.data[i].src<br>//5创建后给新创建的元素添加上瀑布流效果getCliwidth(“cont”,”box”);<br>function checkFlag(){<br>    var parent=document.getElementById(“cont”);<br>    var boximglist=saveBox(parent,”box”);<br>    // console.log(boximglist);//页面有多少图片<br>    var last_boximglist=boximglist[boximglist.length-1];<br>    // console.log(last_boximglist);//获取到最后一个图片<br>    var last_boximgtop=last_boximglist.offsetTop;<br>    // console.log(last_boximgtop)//获取到最后一张图片距离页面顶部多长<br>    //开始第二步 获取滚动条滚动了多少像素<br>    var scroll_px =document.documentElement.scrollTop||document.body.scrollTop;<br>    // console.log(scroll_px);//滚动条滚动了多少像素<br>    //第三步 获取当前可见页面的高度<br>    var page_height=document.documentElement.clientHeight||document.body.clientHeight;<br>    console.log(“最后一张图片距离顶部高度:”+last_boximgtop+”|滚动条滚动了:”+scroll_px+”像素|”+”页面可见高度：”+page_height);<br>    if(scroll_px+page_height&gt;last_boximgtop){<br>        return true;<br><br>    }<br><br><br>}<br><br>function getCliwidth(parent,content){<br>    var parent =document.getElementById(parent);//先获取到最高级的父级元素<br>    var allbox=saveBox(parent,content);//现在已经获取到sava_box数组了 所有的盒子全部保存在这里<br>    // console.log(allbox);//控制台展示获取到多少盒子<br>    var firstwidth =allbox[0].offsetWidth;//获取到图片的宽度 因为css已经固定了宽度为200px<br>    var scnwidth = document.documentElement.clientWidth;//然后获取到屏幕的宽度<br>    var cols =Math.floor(scnwidth/firstwidth);//用屏幕总宽度除以图片的宽度 就可以获取到第一列可以放多少个图片了<br>    parent.style.cssText=”width:”+cols<em>firstwidth+”px;margin:0px auto”;//设置cont的宽度为列数乘以图片宽度<br>    var eboxheight=[];//设置个数组来储存盒子的高度<br>    for (var i = 0; i &lt; allbox.length; i++) {<br>        if(i&lt;cols){//只获取第一列的图片高度<br>            eboxheight[i]=allbox[i].offsetHeight;//在数组eboxheight存储第一列每个盒子的高度<br><br>        }else{<br>            var minheightbox=Math.min.apply(null,eboxheight);//设置一个变量来存储高度数组中最小高度的盒子高度 而不是位置<br>            var minheightboxpostion =getMinheight(eboxheight,minheightbox);//获取到高度最小盒子的位置 这才是位置 也就是数组下标<br>            allbox[i].style.position=”absolute”;//设置第二列盒子的定位为绝对定义 这样才可以设置 top left属性<br>            allbox[i].style.top=minheightbox+”px”;//设置第二列图片的顶部距离为 第一列最小图片的高度<br>            allbox[i].style.left=allbox[minheightboxpostion].offsetLeft+”px”;//设置第二列图片的居左为第一列最小图片的居左属性<br>            eboxheight[minheightboxpostion]=eboxheight[minheightboxpostion]+allbox[i].offsetHeight;//把第一列最小盒子的高度加上第二列图片的高度<br><br><br><br>        }<br>    };<br><br>}<br><br>function getMinheight(eboxheight,minheightbox){//获取第一列最小图片高度的位置<br>    var i;//定义个变量i来遍历<br>    for(i in eboxheight){//<br>        if(eboxheight[i]==minheightbox){<br>            //如果盒子高度数组的高度等于最小高度 返回这个图片的下标 也就是位置<br>            return i;<br><br>        }<br><br>    }<br><br>}<br><br>function saveBox(parent,content){<br>    var save_box=[];//创建个保存盒子数组<br>    var parentnum =parent.getElementsByTagName(“</em>“);//获取到cont元素下面有多少个元素<br>    for (var i = 0; i &lt; parentnum.length; i++) {//开始遍历寻找cont元素下有多少个元素<br>        if(parentnum[i].className==content){//因为我们只要盒子所以 所以我们要判断元素的classname等于box就行了<br>            //检测cont下面的div元素的className是否等于content<br>            save_box.push(parentnum[i]);//然后把这些元素全部存储进去<br>        }<br><br>    };<br>    return save_box;<br><br>}</pre><br><p><strong><span style="color: #993366;"> style.css</span></strong></p><br><pre class="lang:default decode:true ">*{<br>    margin: 0px;<br>    padding: 0px;<br>}<br>#con{<br>    position: relative;<br>}<br>.box{<br>    padding: 5px;<br>    float:left;<br><br>}<br>.box_img{<br>    border: 1px solid #cccccc;<br>    padding: 5px;<br>    box-shadow: 0 0 5px #ccc;<br>    border-radius: 5px;<br>}<br>.box_img img{<br>    width: 200px;<br>    height: auto;<br>}</pre><br><p>代码+图片打包下载<br><br><div class="down shortcodestyle icon-download"><a href="http://pan.baidu.com/s/1qWDiwgc" target="_blank">度娘下载</a></div></p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Soul
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>