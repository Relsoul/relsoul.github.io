<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Soul的随笔</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Soul的随笔">
<meta property="og:url" content="http://emufan.com/page/4/index.html">
<meta property="og:site_name" content="Soul的随笔">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Soul的随笔">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Soul的随笔" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?aa495dca780db3bca4942d20b6eda966";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Soul</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/了不起的nodejs/" style="font-size: 20px;">了不起的nodejs</a> <a href="/tags/了不起的nodejs读书笔记/" style="font-size: 10px;">了不起的nodejs读书笔记</a> <a href="/tags/自言语/" style="font-size: 10px;">自言语</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://emufan.com/">soul随笔</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Soul</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Soul</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-198ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/198ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/198ver/">JS-继承-1:继承者们</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>快混乱了,啃完JavaScript高级程序设计后 赶紧啃啃W3c的继承和对象教程压压惊..</p><br><p>推荐在看这篇文章的时候去看看W3c的继承和对象 这样相对而言比较好理解</p><br><p><a href="http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp" target="_blank" rel="external">http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp</a></p><br><p>本文最重要的第三点 也就是组合继承的最重要一点就是 call(this)理解了这句话估计也就掌握了继承</p><br><p>本章解释了继承的几种方法</p><br><blockquote><br><ol><br><li>继承之原型链 //原型链来继承 实例会公用原型链的属性</li><br><li>借用构造函数// 组合继承的初始版本</li><br><li>组合继承//学会这个就OK了..再看下去..我觉得你跟我一样会转晕的.用构造函数建立属性 原型建立方法</li><br></ol><br></blockquote><br><p>&nbsp;</p><br><pre class="lang:default decode:true ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-继承-1-继承者们&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>    //每个构造函数都有一个原型对象,原型对象都包含一个指向构造函数的指针,实例都包含一个指向原型对象内部的指针<br>    //继承之原型链<br><br>    function Soul1(){//构造函数 对象Soul1<br>        this.name=”soul1”<br>    }<br>    Soul1.prototype.getName = function(){//定义 Soul1的原型函数getName<br>        return this.name;//this指向调用这个函数的 变量，对象等等<br>    };<br>    function Soul2(){//构造函数 对象Soul2<br>        this.age=”19”<br>    }<br>    Soul2.prototype=new Soul1()//对象Soul2的原型等于Soul1<br><br>    Soul2.prototype.getAge=function(){//定义 Soul2的原型函数getAge<br>        return this.age<br>    }<br>    var soul1_1=new Soul2();<br>    var soul1_2=new Soul1();<br>    console.log(soul1_1.getAge())//ok 这是Soul2中的age 那么来试试Soul1中的name<br>    console.log(soul1_1.getName())//ok 获取到Soul1中的name<br>    // console.log(soul1_2.getAge())//error 不能越级访问..也就是说 Soul2定义的函数,属性 Soul1都不能访问到<br>    console.log(soul1_1 instanceof Object)//soul1_1是Object 所有的对象都是Object的实例<br>    console.log(soul1_1 instanceof Soul1)//true<br>    console.log(Object.prototype.isPrototypeOf(soul1_1))//soul1_1原型是Object<br><br>    //谨慎的定义方法<br>    Soul2.prototype.getName=function(){//重写超类型(指的是Soul1)中的getName函数 注意 这语句必须放Soul1_1=new Soul2()之下<br>        return this.age+this.name<br>    }<br>    console.log(soul1_1.getName())<br><br>    // Soul2.prototype={//用字面量添加新方法会导致Soul2.prototype=new Soul1() 失效<br>    //     this.name=name<br>    // }<br>    function Soul3(){//构造函数 Soul3<br>        this.color=[“红色”,”黑色”]//创建 颜色数组<br>    }<br>    function Soul4(){}//构造函数 Soul4<br><br>    Soul4.prototype=new Soul3()//Soul4的原型等于Soul3的原型<br><br>    var Soul3_1 = new Soul4()//创建Soul4的实例<br>    Soul3_1.color.push(“蓝色”)//在Soul3_1的颜色数组添加蓝色<br>    console.log(Soul3_1.color)//输出颜色数组<br><br>    var Soul3_2 = new Soul4()//创建Soul4的实例<br>    console.log(Soul3_2.color)//输出颜色数组<br>    //发现 创建了Soul3_1 和Soul3_2 两个实例都共享了color数组<br><br>    //组合继承(将原型和借用构造函数组合)<br>    //构造函数构造属性 原型建立方法<br>    function Soul5(name){<br>        this.name= name;<br>        this.color=[“蓝色”,”绿色”,”黄色”];<br>        }<br>    Soul5.prototype.sayName=function(){<br>        console.log(“Soul5名字”+this.name);<br>    }<br>    function Soul7(name,age){<br>        //关键代码就是call<br>        Soul5.call(this,name);//向Soul5传递this.name  比如Soul7_1用这个函数构建name属性的 this就相当于Soul7_1<br><br>        this.age=age;//age Soul7自己处理<br>    }<br>    //继承方法<br>    Soul7.prototype=new Soul5();<br>    Soul7.prototype.constructor=Soul7 //Soul7构造函数并不指向Soul5 而是指向自己<br>    Soul7.prototype.sayAge=function(){<br>        console.log(“Soul7年龄:”+this.age)<br>    }<br>    var Soul7_1 =new Soul7(“Soul7name”,”19”)//构造Soul7的实例Soul7_1<br>    Soul7_1.color.push(“Soul7_1红色”)//在Soul7_1实例中的color数组添加新元素<br>    Soul7_1.sayName();//Soul7_1是Soul7的实例 但是Soul7继承了Soul5的原型,所以Soul7_1继承了Soul5的方法和属性<br>    Soul7_1.sayAge();//同上<br>    console.log(Soul7_1.color)<br><br>    var Soul7_2=new Soul7(“Soul7_2的名字”,”18”)//同上<br>    Soul7_2.color.push(“Soul7_2黑色”)<br>    Soul7_2.sayName();<br>    Soul7_2.sayAge();<br>    console.log(Soul7_2.color)<br>    //以上代码都继承了 Soul5的原型 但是用构造函数创建属性 并且指定Soul7的原型构造函数等于Soul7<br>    //所以Soul7_1和Soul7_2公用构造函数Soul7但是这个构造函数Soul7的原型构造函数等于他本身,所以不会<br>    //重写Soul5构造函数的属性<br>    //…绕的有点多..多理解一下就ok了<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-199ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/199ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/199ver/">JavaScript this浅解:谁?是谁调戏(yong)了我</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><!--StartFragment --></p><p></p>
<div>&lt;a href=”abc” onclick=”function(){console.log(this.href)}” &gt;&lt;/a&gt;</div><br><div></div><br><div>this指向的就是A元素</div><br><div>function Soul2(){<br><br>this.age=”19”<br><br>}</div><br><div>var abc =new Soul2()</div><br><div>this指向的就是abc</div><br><div></div><br><div>看不懂？没关系来个简单的</div><br><div></div><br><div><!--StartFragment --><p></p><br><div>this的意思就相当于<br><br>我是员工<br><br>A BOSS调戏(yong)了我 就指向ABOSS<br><br>B BOSS调戏(yong)了我 就指向B BOSS</div><br></div>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-200ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/200ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/200ver/">JavaScript对象-1:对象弹琴</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScript对象还真难理解,已经卡了两天,估计还要卡几天,目前分析了一下对象的创建</p><br><blockquote><br><ol><br><li>字面量创建对象</li><br><li>工程模式创建对象</li><br><li>构造函数创建对象</li><br><li>原型模式创建对象</li><br><li>组合使用构造模式与原型模式//常用</li><br><li>动态原型模式//不推荐</li><br><li>寄生构造函数模式//不推荐</li><br><li>稳妥构造函数模式//代码没写..这种模式主要是安全性高 具体的可以推度娘一下</li><br></ol><br><p>代码下载<div class="down shortcodestyle icon-download"><a href="http://pan.baidu.com/s/1c0lMAVu" target="_blank">度娘下载</a></div></p></blockquote><br><p>&nbsp;</p><br><pre class="lang:default decode:true ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-对象-1:对象弹琴&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>    //创建对象之字面量创建<br>    var soul={};//ok 这就创建了一个对象<br>    soul.tc=function(){console.log(“hello,我是弹窗的soul的对象”)};<br>    soul.tc();//这就相当于调用了soul.tc的对象<br><br>    var soul1={//这样也可以创建个对象<br>        name:”soul”,//这样创建用逗号分隔<br>    }<br>    console.log(soul1.name)//<br><br>    //理解对象<br>    var Soul3 =new Object();<br>    Soul3.name=”soul”<br>    Soul3.sayName=function(){console(“Soul3的sayName函数对象”)+this.name}//this.name被解析成Soul3.name<br>    //也可以通过var Soul3={}这样的形式来创建对象<br>    console.log(“我是分隔线 下面开始理解对象之数据属性”)<br>    //理解对象之数据属性<br>    var Soul4={};<br>    Object.defineProperty(Soul4,”name”, {//三个值分别对应 对象名字 对象属性 描述 PS:IE9以上支持<br>        writable:false,//能否修改属性的值 默认是true 用逗号分隔<br>        value:”Soul4”//相当于 name=”Soul4”<br>    });<br>    console.log(Soul4.name)//获取Soul4的name属性值<br>    Soul4.name=”更改Soul4”<br>    console.log(“能否获取到更改Soul4后的name属性值:”+Soul4.name);//因为writable:false 所以禁止修改<br>    //<br>    var Soul5={};<br>    Object.defineProperty(Soul5,”name”, {//三个值分别对应 对象名字 对象属性 描述<br>        configurable:false,//能否删除属性 是否能够更改属性为访问器属性 默认是true 用逗号分隔<br>        value:”Soul5”//相当于 name=”Soul5”<br>    });<br>    console.log(“Soul5的name属性:”+Soul5.name);<br>    delete Soul5.name;//删除Soul5_name属性<br>    console.log(“删除了Soul5的name属性吗？:”+Soul5.name)<br>    //理解对象之访问器属性<br>    console.log(“我是分隔线，下面开始理解对象之访问器属性”);<br><br>    var Soul6 ={<br>        _year:2015,<br>        num:1//这是一个属性<br>    };<br>    Object.defineProperty(Soul6, “year”, {<br>        get:function(){//读取year属性的时候做出的行动<br>            return this._year;//返回this._year this解析为 Soul6<br>        },//用逗号分隔<br>        set:function(new_value){<br>            if(new_value&gt;2015){<br>                this._year=new_value;<br>                this.num=new_value-2015;<br>            }<br>        }<br><br>    });<br>    console.log(“这是读取Soul6的_year属性做出的行动”+Soul6.year);<br>    Soul6.year=2018;<br>    console.log(“更改Soul6的_year属性时会设置num等于新属性减去_year:”+Soul6.num);<br>    //理解对象之定义多个属性<br>    var Soul7={};<br>    Object.defineProperties(Soul7, {//两个参数分别对应是 对象名 描述 PS:IE9以上支持<br>        _year:{<br>            value:2015<br>        },//用逗号分隔<br><br>        num:{<br>            value:1<br><br>        },<br><br>        year:{<br>            get:function(){<br>                return this._year<br>            }<br>        },<br><br>        set:function(new_value) {<br>            if(new_value&gt;2015){<br>                this._year=new_value;<br>                this.num=new_value-2015;<br>            }<br>        }<br><br>    })<br>    //上面这段代码跟Soul6是一样的意思<br>    console.log(“我是分隔线,下面开始理解对象之读取属性的特性”)<br>    //理解对象之 读取属性的特性<br>    var miao_shu =Object.getOwnPropertyDescriptor(Soul7, “_year”);//设置miao_shu 等于Soul7的 _year描述<br>    console.log(“获取Soul7的_year值:”+miao_shu.value);<br>    console.log(“获取Soul7的_year属性能否读写:”+miao_shu.configurable);<br><br>    //下面开始创建对象<br>    console.log(“我是分隔线,下面开始创建对象”)<br><br>    //工厂模式创建对象<br>    function Soul9(name,age,job){<br>        var o=new Object();<br>        o.name=name;<br>        o.age=age;<br>        o.job=job;<br>        o.sayName=function(){console.log(“工程模式创建Soul9的sayName函数”)+this.name};<br>        return o;<br>    }<br>    var Soul9_1=Soul9(“Soul9_1”,19,”学生”);<br>    var Soul9_2=Soul9(“Soul9_2”,20,”学生”);<br><br><br><br><br>    //构造函数模式创建对象<br>    function Soul2(name,age,job){<br>        this.name=name;//this指的是当前传递参数的函数调用<br>        this.age=age;<br>        this.job=job;<br>        this.sayName=function(){console.log(“soul2对象sayName函数:”+this.name)}<br>    }<br>    // var soul_1=soul2(“我叫soul”,19,”student”);//..这样给对象传递参数是不对<br>    var soul_2 =new Soul2(“我叫soul”,19,”student”);<br>    var soul_3 =new Soul2(“我叫灵魂”,20,”学生”);<br>    console.log(soul_2.name);//看看能不能获取到soul_2对象的name属性<br>    soul_3.sayName();//看看能不能获取到osul2对象的sayName函数<br>    //来检测下soul_2和soul_3是不是Soul2的实例？<br>    console.log(soul_2.constructor == Soul2);//“soul_2和soul_3都是构造函数” 是=true 否=false //soul_3就不列举了<br>    console.log(soul_3 instanceof Object)//所有的对象都是Object的实例 true<br>    console.log(soul_2 instanceof Soul2)//true 是Soul2的实例<br><br>    //将构造函数当做函数<br>    var soul_2 =new Soul2(“window弹出|我叫soul”,19,”student”);//构造函数<br>    soul_2.sayName()//构造函数<br><br>    Soul2(“我叫soul”,19,”student”);//普通函数<br>    window.sayName();//添加到window<br><br>    var o =new Object();//跨域函数<br>    Soul2.call(o,”我叫Soul-跨域函数”,19,”student”);//<br>    o.sayName();<br><br>    //原型模式<br>    console.log(“我是分隔线,下面开始理解原型模式”)<br>    function Soul10(){}//创建一个Soul10对象<br>    Soul10.prototype.name = “Soul10”//给Soul10对象添加个原型属性name<br>    Soul10.prototype.sayName=function(){console.log(“原型模式:”+this.name)}//this指的是Soul10的name<br>    var soul_10 =new Soul10();//<br>    var soul_11 =new Soul10();<br>    console.log(“原型模式 soul_10 name:”+soul_10.name)<br>    soul_11.sayName();<br>    console.log(soul_11.sayName==soul_10.sayName)//判断soul_11的sayName是否跟soul_10的sayName函数一样 是-true<br>    //原型与实例<br>    //当调用时首先搜索 实例 如果实例没属性再搜索原型 在实例定义属性会覆盖掉原型<br><br>    soul_10.name=”实例hello”<br>    console.log(soul_10);<br>    delete soul_10.name;<br>    console.log(soul_10)//原型 Soul10<br>    //使用 hasOwnProperty检测属性是来自原型还是实例 来自原型-false 实例true<br>    console.log(soul_10.hasOwnProperty(“name”))<br><br>    //原型与in操作符<br>    console.log(“name” in soul_10)//检测soul_10里有没有name属性 不管name属性是原型还是实例<br>    var save_soul_10 =Object.getOwnPropertyNames(Soul10.prototype);//枚举 Soul10的实例<br>    console.log(“枚举soul_11的属性”+save_soul_10)<br><br>    //更简单的原型语法<br>    function Soul13 () {}<br>    Soul13.prototype={<br>        name:”Soul13”,<br>        sayName:function () {<br>            console.log(this.name)<br>        }<br>    }<br>    var soul_13 =new Soul13()<br>    //每创建一个函数,都会创建它的prototype对象 这个对象也会获得constructor属性(这个指向构造函数)<br>    //但是用字面量方法创建重写了prototype对象 constructor也不会指向Soul3<br>    console.log(soul_13.constructor == Soul13)//false<br>    //如果constructor属性很重要 可以通过添加一句话来指向原型<br>    function Soul14 () {}<br>    Soul14.prototype={<br>        name:”Soul14”,<br>        constructor:Soul14//这样就会始终指向Soul14<br>    }<br>    var soul_14 =new Soul14()<br>    console.log(soul_14.constructor == Soul14);//true<br><br>    //原型的动态性<br>    var soul_15 =new Soul14()<br>    Soul14.prototype.hello=function(){console.log(“原型动态性”)}//<br>    soul_15.hello();<br>    //以上先创建了 Soul14的实例 保存在soul_15中 然后给Soul14原型添加了一句方法<br>    //我们调用soul_15.hello()时,先会在实例中搜索hello,如果实例没有再搜索原型<br><br>    //实例中的指针[Prototype]只指向原型,而不指向构造函数<br>    function Soul15(){}//这是个构造函数<br>    var soul_16 =new Soul15();//创建个Soul15的实例<br>    Soul15.prototype={<br>        name:”hello”,<br>        saySoul:function(){console.log(this_name)}<br>    }<br>    // soul_16.saySoul();//error<br>    //上文说过了 实例中指针[Prototype]只指向原型,而我们在创建实例后又重写了<br>    //一开始 soul_16指向的是Soul15的原型,但是下一步我们又重写了原型,所以soul_16指向的<br>    //仅仅是 原来的原型. 而不是新的原型<br><br>    //原生对象的原型<br>    console.log(“我是分隔线,下面开始原生对象的原型”)<br>    //<br>    console.log(typeof Array.prototype.sort)//数组的sort方法,返回的是一个函数<br><br>    //定义原生对象的方法<br>    String.prototype.CZ=function(txt){<br>        return this.indexOf(txt);//查找txt字符是从哪开始的<br>    }<br>    var txt=”soul”<br>    console.log(txt.CZ(“o”))//o是soul中的第一个字符 字符从0开始的<br><br>    //原型对象的问题<br><br><br>    function Soul16(){}<br>    Soul16.prototype={<br>        name:[“张三,李四”]<br>    }<br>    var soul_16_1=new Soul16();<br>    var soul_16_2=new Soul16();<br>    soul_16_1.name.push(“王五”)//在soul_16_1.name属性后面添加王五<br>    console.log(soul_16_2.name);//我输出的是soul_16_2.name 而非soul_16_1.name 为什么还会有王五？<br>    //因为soul_16_1与2 都是共享一个原型Soul16<br><br>    //组合使用构造函数模式与原型模式<br>    console.log(“我是分隔线,下面开始组合使用构造函数模式与原型模式”)<br><br>    //构造函数模式用于定义实例属性, 而原型模式用于定义方法和共享的属性s<br><br>    function Soul17(name,age){<br>        this.soul=[“灵魂”,”灵魂追逐着”]//不加this会找不到soul属性<br>        this.name=name<br>        this.age=age<br>    }<br><br>    Soul17.prototype={<br>        constructor:Soul17,<br>        sayName:function(){console.log(this.name)}<br>    }<br>    var soul17_1=new Soul17(“soul”,”19”)<br>    var soul17_2=new Soul17(“我是soul17_2”,”19”)<br>    soul17_2.soul.push(“hello”)<br>    console.log(“soul17_2:”+soul17_2.soul);<br>    console.log(“soul17_1:”+soul17_1.soul);<br>    soul17_2.sayName();<br>    //用构造函数定义属性 用原型定义方法 共享方法,修改属性却不共享<br><br>    //寄生构造函数模式<br>    console.log(“我是分隔线,下面开始动态原型模式”)<br>    function Soul18(){<br>        var soul18_arr =new Array();<br>        soul18_arr.push.apply(soul18_arr,arguments)<br>        soul18_arr.setSoul18=function(){<br>            return this.join(“|”)//使用不同的分隔符<br>        }<br>        return soul18_arr//返回数组<br>    }<br>    var soul18_1 =new Soul18(“red”,”blue”);<br>    console.log(soul18_1.setSoul18())<br>    //能使用其他模式的情况下 不建议使用这种模式<br><br><br><br><br><br><br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-201ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/201ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/201ver/">【转】阮一峰大师的Javascript 面向对象编程（一）：封装</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通俗易懂 转自<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html</a></p><br><p>学习Javascript，最难的地方是什么？</p><br><p>我觉得，Object（对象）最难。因为Javascript的Object模型很独特，和其他语言都不一样，初学者不容易掌握。</p><br><p>下面就是我的学习笔记，希望对大家学习这个部分有所帮助。我主要参考了以下两本书籍：</p><br><p><img src="http://image.beekka.com/blog/201005/bg2010051701.jpg" data-original="http://image.beekka.com/blog/201005/bg2010051701.jpg" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt=""></p><br><p><a href="https://www.packtpub.com/object-oriented-javascript-applications-libraries/book" target="_blank">《面向对象的Javascript》</a>（Object-Oriented JavaScript）</p><br><p><img src="http://image.beekka.com/blog/201005/bg2010051702.jpg" data-original="http://image.beekka.com/blog/201005/bg2010051702.jpg" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt=""></p><br><p><a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-JavaScript-for-Web-Developers-2nd-Edition.productCd-047022780X.html" target="_blank">《Javascript高级程序设计（第二版）》</a>（Professional JavaScript for Web Developers, 2nd Edition)</p><br><p>它们都是非常优秀的Javascript读物，推荐阅读。</p><br><p>笔记分成三部分。今天的第一部分是讨论”封装”（Encapsulation），后面的<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank">第二部分</a>和<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank">第三部分</a>讨论”继承”（Inheritance）。</p><br><p>============================</p><br><p><strong>Javascript 面向对象编程（一）：封装</strong></p><br><p>作者：阮一峰</p><br><p>Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。</p><br><p>那么，如果我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？</p><br><p><strong>一、 生成对象的原始模式</strong></p><br><p>假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。</p><br><blockquote><p>　　var Cat = {</p><br><p>name : ‘’,</p><br><p>color : ‘’</p><br><p>}</p></blockquote><br><p>现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。</p><br><blockquote><p>　　var cat1 = {}; // 创建一个空对象</p><br><p>cat1.name = “大毛”; // 按照原型对象的属性赋值</p><br><p>cat1.color = “黄色”;</p><br><p>var cat2 = {};</p><br><p>cat2.name = “二毛”;</p><br><p>cat2.color = “黑色”;</p></blockquote><br><p>好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p><br><p><strong>二、 原始模式的改进</strong></p><br><p>我们可以写一个函数，解决代码重复的问题。</p><br><blockquote><p>　　function Cat(name,color){</p><br><p>return {</p><br><p>name:name,</p><br><p>color:color</p><br><p>}</p><br><p>}</p></blockquote><br><p>然后生成实例对象，就等于是在调用函数：</p><br><blockquote><p>　　var cat1 = Cat(“大毛”,”黄色”);</p><br><p>var cat2 = Cat(“二毛”,”黑色”);</p></blockquote><br><p>这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p><br><p><strong>三、 构造函数模式</strong></p><br><p>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。</p><br><p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank">this变量</a>。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</p><br><p>比如，猫的原型对象现在可以这样写，</p><br><blockquote><p>　　function Cat(name,color){</p><br><p>this.name=name;</p><br><p>this.color=color;</p><br><p>}</p></blockquote><br><p>我们现在就可以生成实例对象了。</p><br><blockquote><p>　　var cat1 = new Cat(“大毛”,”黄色”);</p><br><p>var cat2 = new Cat(“二毛”,”黑色”);</p><br><p>alert(cat1.name); // 大毛</p><br><p>alert(cat1.color); // 黄色</p></blockquote><br><p>这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。</p><br><blockquote><p>　　alert(cat1.constructor == Cat); //true</p><br><p>alert(cat2.constructor == Cat); //true</p></blockquote><br><p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p><br><blockquote><p>　　alert(cat1 instanceof Cat); //true</p><br><p>alert(cat2 instanceof Cat); //true</p></blockquote><br><p><strong>四、构造函数模式的问题</strong></p><br><p>构造函数方法很好用，但是存在一个浪费内存的问题。</p><br><p>请看，我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：</p><br><blockquote><p>　　function Cat(name,color){</p><br><p>this.name = name;</p><br><p>this.color = color;</p><br><p>this.type = “猫科动物”;</p><br><p>this.eat = function(){alert(“吃老鼠”);};</p><br><p>}</p></blockquote><br><p>还是采用同样的方法，生成实例：</p><br><blockquote><p>　　var cat1 = new Cat(“大毛”,”黄色”);</p><br><p>var cat2 = new Cat (“二毛”,”黑色”);</p><br><p>alert(cat1.type); // 猫科动物</p><br><p>cat1.eat(); // 吃老鼠</p></blockquote><br><p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p><br><blockquote><p>　　alert(cat1.eat == cat2.eat); //false</p></blockquote><br><p>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p><br><p><strong>五、 Prototype模式</strong></p><br><p>Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p><br><p>这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p><br><blockquote><p>　　function Cat(name,color){</p><br><p>this.name = name;</p><br><p>this.color = color;</p><br><p>}</p><br><p>Cat.prototype.type = “猫科动物”;</p><br><p>Cat.prototype.eat = function(){alert(“吃老鼠”)};</p></blockquote><br><p>然后，生成实例。</p><br><blockquote><p>　　var cat1 = new Cat(“大毛”,”黄色”);</p><br><p>var cat2 = new Cat(“二毛”,”黑色”);</p><br><p>alert(cat1.type); // 猫科动物</p><br><p>cat1.eat(); // 吃老鼠</p></blockquote><br><p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</p><br><blockquote><p>　　alert(cat1.eat == cat2.eat); //true</p></blockquote><br><p><strong>六、 Prototype模式的验证方法</strong></p><br><p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p><br><p><strong>6.1 isPrototypeOf()</strong></p><br><p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p><br><blockquote><p>　　alert(Cat.prototype.isPrototypeOf(cat1)); //true</p><br><p>alert(Cat.prototype.isPrototypeOf(cat2)); //true</p></blockquote><br><p><strong>6.2 hasOwnProperty()</strong></p><br><p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。</p><br><blockquote><p>　　alert(cat1.hasOwnProperty(“name”)); // true</p><br><p>alert(cat1.hasOwnProperty(“type”)); // false</p></blockquote><br><p><strong>6.3 in运算符</strong></p><br><p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p><br><blockquote><p>　　alert(“name” in cat1); // true</p><br><p>alert(“type” in cat1); // true</p></blockquote><br><p>in运算符还可以用来遍历某个对象的所有属性。</p><br><blockquote><p>　　for(var prop in cat1) { alert(“cat1[“+prop+”]=”+cat1[prop]); }</p></blockquote><br><p>未完，请继续阅读这个系列的第二部分<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank">《构造函数的继承》</a>和第三部分<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank">《非构造函数的继承》</a>。</p><br><p>（完）</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-202ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/202ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/202ver/">【转】JavaScript基础之对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转自<a href="http://www.cnblogs.com/syuko/archive/2008/03/05/1091843.html" target="_blank" rel="external">http://www.cnblogs.com/syuko/archive/2008/03/05/1091843.html</a></p><br><p>JavaScript基础之对象</p><br><p>从2004年下半年开始学习Web编程至今3年有余。从HTML，asp开始到现在的VS2008一路学过来，其中学的最多的还是服务器端编程，对客户端编程的学习还是不成系统。虽然在很多个系统里面应用过脚本，有些还起到了比较重要的作用。但一直是只知其然不知其所以然，用的是小心翼翼。现在脚本编程从以前的”雕虫小技”变成了一个Web开发不可或缺的元素，其地位大大提高了，特别是Ajax兴起之后它更是”炙手可热”了。鉴于此种情况及自己对脚本编程的热爱，于是就系统地学习一下脚本。</p><br><p>学习是理解和记忆的过程。在理解和记忆的过程中必不可少地就需要一些辅助的记录，于是我就将自己的学习记录写成随笔。一来是帮助自己理解和记忆，二来也给其它热爱脚本的同志一些参考。</p><br><p>1 JavaScript对象</p><br><p>ECMA-262将对象（object）定义为”属性的无序集合，每个属性存放一个原始值、对象或函数”（unordered collection of properties each of which contains a primitive value, object, or function）。这意味着对象是无特定顺序的值的数组。在ECMAScript中，对象由特性（Attribute）构成，特性可以是原始值，也可以是引用值。如果特性存放的是函数，它将被看作对象的方法（Method），否则该特性被看作属性（Property）。</p><br><p>2 对象的废除</p><br><p>ECMAScript有无用存储单元收集程序（就像C#的垃圾收集器），意味着不必专门销毁对象来释放内存。当再没有对对象的引用时，该对象就被废除了。运行无用存储单元收集程序时，所有废除的对象都会被销毁。每当函数执行完它的代码，无用存储单元收集程序都会运行，释放所有的局部变量，还有在一些其它不可预知的情况下，无用存储单元收集程序也会运行。<br><br>把对象的所有引用都设置为null，可以强制性的废除对象。例如：</p><br><p>Var oObject=new Object();</p><br><p>// 程序逻辑</p><br><p>oObject=null;</p><br><p>当变量oObject设置为null后，对第一个创建的对象的引用就不存在了。这意味着下次运行无用存储单元收集程序时，该对象将被销毁。<br><br>每用完一个对象后，就将其废除，来释放内存，这是个好习惯。这样还确保不再使用已经不能访问的对象，从而防止程序设计错误的出现。此外，旧的浏览器（如IE）没有完全的无用存储单元收集程序，所以卸载页面时，对象可能不能被正确地销毁。以前IE6就有这样的诟病，当页面被关闭后对象还是没有被释放，所以总是会导致内存溢出的错误。废除对象和它所有的特性是确保内存正确使用的最好方法。</p><br><p>3 对象的类型</p><br><p>JavaScript中对象分为：本地对象（native object）、内置对象（built-in object）、宿主对象（host object）。其中本地对象和宿主对象大家一般用的比较多，比较熟。这里我就重点说明一下内置对象。<br><br>ECMA-262把内置对象定义为”由ECMAScript实现提供的、独立于宿主环境的所有对象，在ECMAScript程序开始执行时出现”（any object supplied by an ECMAScript implementation, independent of the host environment, which is present at the start of the execution of an ECMAScript program.）。这意味着开发者不必明确实例化内置对象，它已经被实例化了。但ECMAScript只定义了两个内置对象：</p><br><p>3.1 Math对象</p><br><p>Math对象就是解决数学问题的所有公式。这个在各种编程语言中都有类似的实现，就不做介绍了。</p><br><p>3.2 Global对象</p><br><p>园子里很多搞ASP.net的，相信大家对其中的Global.asax非常熟悉了。但这个对象在ECMAScript中却比较特殊。因为它实际上根本就不存在。如果尝试编写下面的代码去实例化它，将得到错误：<br><br>Var _global=new Global();<br><br>错误消息显示Global不是对象，但上文却说Global是一个内置对象，这不就自相矛盾了吗？不矛盾。这里需要理解的主要概念是，在ECMAScript中，不存在独立的函数，所有的函数都必须是某个对象的方法。ECMAScript中常用的函数例如isNaN()、isFinite（）等，看起来都像独立的函数。实际上，它们都是Global对象的方法。而且Global对象的方法还不止这些。</p><br><p>4 定义类或对象</p><br><p>虽然ECMAScript越来越正规化了，但创建对象的方法却被置之不理。在高级的编程语言（如C#）中，创建对象的方法被明确的定义了。所以不会有太大的分歧。但在脚本语言中创建对象的方法就是多种多样了。</p><br><p>4.1 工厂方式</p><br><p>由于对象的属性可在对象创建后动态定义，所以许多开发者都在初次引入JavaScript时编写类似下面的代码：<br><br>Var oCar=new Object();<br><br>oCar.color=”red”;<br><br>oCar.doors=4;<br><br>oCar.mpg=23;<br><br>oCar.showColor=function(){alert(this.color);};<br><br>在这段代码中，创建对象car。然后给它设置几个属性：它的颜色是红色，有四个门，每加仑油23英里。最后一个属性是指向函数的指针，意味着该属性其实是个方法。执行这段代码后，就可以使用对象car了。可是要创建多个car实例就麻烦了。<br><br>要解决此问题，开发者可以创建并返回特定类型的对象的工厂函数。例如，函数CreateCar（）可用于封装前面列出的创建car对象的操作：<br><br>Function createCar()<br><br>{<br><br>Var oTempCar=new Object();<br><br>oTempCar.color=”red”;<br><br>oTempCar.doors=4;<br><br>oTempCar.mpg=23;<br><br>oTempCar.showColor=function(){alert(this.color)};</p><br><p>return oTempCar;<br><br>}</p><br><p>Var oCar1=createCar();<br><br>Var oCar2=createCar();</p><br><p>这里，前面的所有代码都包含在createCar()函数中，此外还有一行额外的代码，返回Car对象作为函数值。调用此函数时，将创建新对象，并赋予它所有必要的属性，复制出一个前面说明的car对象。使用该方法，可以容易地创建car对象的两个版本，他们的属性完全一样。当然，还可以修改creatCar（）函数，给它传递各个属性的默认值，而不是赋予属性默认值：<br><br>Function createCar(sColor,iDoors,iMpg)<br><br>{<br><br>Var oTempCar=new Object();<br><br>oTempCar.color= sColor;<br><br>oTempCar.doors= iDoors;<br><br>oTempCar.mpg= iMpg;<br><br>oTempCar.showColor=function(){alert(this.color)};</p><br><p>return oTempCar;<br><br>}</p><br><p>Var oCar1=createCar(“red”,4,23);<br><br>Var oCar2=createCar(“blue”,2,26);<br><br>oCar1.showColor();            // 输出”red”<br><br>oCar2.showColor();            // 输出”blue”</p><br><p>给createCar（）函数加上参数，即可为要创建的car对象的color、doors和mpg属性赋值。使这两个对象具有相同的属性，却有不同的属性值。但这里有个问题：每次调用函数createCar（），都要创建新函数showColor()，意味着每个对象都有自己的showColor（）版本。事实上，每个对象用的都是同一段代码。这样的定义方法还有一个如下的变形：<br><br>Function Car(sColor,iDoors,iMpg)<br><br>{<br><br>this.color= sColor;<br><br>this.doors= iDoors;<br><br>this.mpg= iMpg;<br><br>this.showColor=function(){alert(this.color)};<br><br>}</p><br><p>Var oCar1=new Car(“red”,4,23);<br><br>Var oCar2=new Car(“blue”,2,26);</p><br><p>oCar1.showColor();            // 输出”red”<br><br>oCar2.showColor();            // 输出”blue”<br><br>这个方法和上一个方法有个一样的缺陷：重复的创建了showColor()函数。为了解决这个缺陷我们可以用下面的方法。</p><br><p>4.2 原型方式</p><br><p>该方法利用了对象的Prototype属性。用空构造函数来设置类名，然后所有的属性和方法都被直接赋予prototype属性：<br><br>Function Car()<br><br>{}</p><br><p>Car.prototype.color=”red”;<br><br>Car.prototype.doors=4;<br><br>Car.prototype.mpg=23;<br><br>Car.prototype.showColor=function(){alert(this.color)};</p><br><p>Var oCar1=new Car();<br><br>Var oCar2=new Car();</p><br><p>使用这个方法可以解决重复创建showColor（）函数，但又会有新的问题，考虑下面的例子：</p><br><p>Function Car()<br><br>{}</p><br><p>Car.prototype.color=”red”;<br><br>Car.prototype.doors=4;<br><br>Car.prototype.mpg=23;<br><br>Car.prototype.drivers=new Array(“Mike”,”Sue”);<br><br>Car.prototype.showColor=function(){alert(this.color)};</p><br><p>Var oCar1=new Car();<br><br>Var oCar2=new Car();</p><br><p>oCar1.drivers.push(“Matt”);</p><br><p>alert(oCar1.drivers);        // 输出”Mike,Sue,Matt”<br><br>alert(oCar2.drivers);        // 输出”Mike,Sue,Matt”</p><br><p>这里，属性drivers是指向Array对象的指针。改变指针指向的内容，所有的实例都会改变。看来这种方法也不可取</p><br><p>4.3 混合方式</p><br><p>这种方式就是用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果所有的函数只创建一次，而每个对象都具有自己的对象属性实例。<br><br>Function Car(sColor,iDoors,iMpg)<br><br>{<br><br>this.color= sColor;<br><br>this.doors= iDoors;</p><br><p>this.mpg= iMpg;<br><br>Car.drivers=new Array(“Mike”,”Sue”);<br><br>}</p><br><p>Car.prototype.showColor=function(){alert(this.color)};</p><br><p>Var oCar1=new Car(“red”,4,23);<br><br>Var oCar2=new Car(“blue”,3,25);</p><br><p>oCar1.drivers.push(“Matt”);</p><br><p>alert(oCar1.drivers);        // 输出”Mike,Sue,Matt”<br><br>alert(oCar2.drivers);        // 输出”Mike,Sue”</p><br><p>这种方式是ECMAScript主要采用的方式，它具有其他方式的特性，却没有它们的缺陷。在实际编程中应用的也是最多了。<br><br>另外还有JSON创建方式。其创建的方式如下：</p><br><p>var Car =<br><br>{<br><br>color: “red”,<br><br>doors: 4,<br><br>mpg: 23,<br><br>drivers: [{name: “Mike”, age: 20, Married: false}, {name: “Sue”, age: 30, Marred: true}],<br><br>showColor: function() {alert(this.color)}<br><br>};<br><br>这种创建对象的方式也比较优雅。可作为Ajax返回的文本，然后用eval()函数将其还原成一个对象。著名的脚本框架JQuery就有专门接收返回文本为JSON对象的异步方法。</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-203ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/203ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/203ver/">【转】领悟 JavaScript 中的面向对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转自<a href="http://www.iteye.com/topic/155109" target="_blank" rel="external">http://www.iteye.com/topic/155109</a></p><br><p>领悟 JavaScript 中的面向对象</p><br><p>&nbsp;</p><br><p>注：读完本文后请务必接着看完所有回复！</p><br><p>JavaScript 是面向对象的。但是不少人对这一点理解得并不全面。</p><br><p>在 JavaScript 中，对象分为两种。一种可以称为“普通对象”，就是我们所普遍理解的那些：数字、日期、用户自定义的对象（如：{}）等等。</p><br><p>还有一种，称为“方法对象”，就是我们通常定义的 function。你可能觉得奇怪：方法就是方法，怎么成了对象了？但是在 JavaScript 中，方法的确是被当成对象来处理的。下面是一个简单的例子：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li><span class="keyword">function</span> func() {alert(<span class="string">‘Hello!’</span>);}</li><br><li>alert(func.toString());</li><br></ol><br></div><br><p>在这个例子中，func 虽然是作为一个方法定义的，但它自身却包含一个 toString 方法，说明 func 在这里是被当成一个对象来处理的。更准确的说，func 是一个“方法对象”。下面是例子的继续：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li>func.name = “I am func.”;</li><br><li>alert(func.name);</li><br></ol><br></div><br><p>我们可以任意的为 func 设置属性，这更加证明了 func 就是一个对象。那么方法对象和普通对象的区别在哪里呢？首先方法对象当然是可以执行的，在它后面加上一对括号，就是执行这个方法对象了。</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li>func();</li><br></ol><br></div><br><p>所以，方法对象具有二重性。一方面它可以被执行，另一方面它完全可以被当成一个普通对象来使用。这意味着什么呢？这意味着方法对象是可以完全独立于其他对象存在的。这一点我们可以同 Java 比较一下。在 Java 中，方法必须在某一个类中定义，而不能单独存在。而 JavaScript 中就不需要。</p><br><p>方法对象独立于其他方法，就意味着它能够被任意的引用和传递。下面是一个例子：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li><span class="keyword">function</span> invoke(f) {</li><br><li>    f();</li><br><li>}</li><br><li>invoke(func);</li><br></ol><br></div><br><p>将一个方法对象 func 传递给另一个方法对象 invoke，让后者在适当的时候执行 func。这就是所谓的“回调”了。另外，方法对象的这种特殊性，也使得 this 关键字不容易把握。这方面相关文章不少，这里不赘述了。</p><br><p>除了可以被执行以外，方法对象还有一个特殊的功用，就是它可以通过 new 关键字来创建普通对象。</p><br><p>话说每一个方法对象被创建时，都会自动的拥有一个叫 prototype 的属性。这个属性并无什么特别之处，它和其他的属性一样可以访问，可以赋值。不过当我们用 new 关键字来创建一个对象的时候，prototype 就起作用了：它的值（也是一个对象）所包含的所有属性，都会被复制到新创建的那个对象上去。下面是一个例子：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li>func.prototype.name=”prototype of func”;</li><br><li><span class="keyword">var</span> f = <span class="keyword">new</span> func();</li><br><li>alert(f.name);</li><br></ol><br></div><br><p>执行的过程中会弹出两个对话框，后一个对话框表示 f 这个新建的对象从 func.prototype 那里拷贝了 name 属性。而前一个对话框则表示 func 被作为方法执行了一遍。你可能会问了，为什么这个时候要还把 func 执行一遍呢？其实这个时候执行 func，就是起“构造函数”的作用。为了形象的说明，我们重新来一遍：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li><span class="keyword">function</span> func() {</li><br><li>    <span class="keyword">this</span>.name=”name has been changed.”</li><br><li>}</li><br><li>func.prototype.name=”prototype of func”;</li><br><li><span class="keyword">var</span> f = <span class="keyword">new</span> func();</li><br><li>alert(f.name);</li><br></ol><br></div><br><p>你就会发现 f 的 name 属性不再是”prototype of func”，而是被替换成了”name has been changed”。这就是 func 这个对象方法所起到的“构造函数”的作用。所以，在 JavaScript 中，用 new 关键字创建对象是执行了下面三个步骤的：</p><br><ol><br><li>创建一个新的普通对象；</li><br><li>将方法对象的 prototype 属性的所有属性复制到新的普通对象中去。</li><br><li>以新的普通对象作为上下文来执行方法对象。</li><br></ol><br><p>对于“new func()”这样的语句，可以描述为“从 func 创建一个新对象”。总之，prototype 这个属性的唯一特殊之处，就是在创建新对象的时候了。<br><br>那么我们就可以利用这一点。比如有两个方法对象 A 和 B，既然从 A 创建的新对象包含了所有 A.prototype 的属性，那么我将它赋给 B.prototype，那么从 B 创建的新对象不也有同样的属性了？写成代码就是这样：</p><br><p>&nbsp;</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li>A.prototype.hello = <span class="keyword">function</span>(){alert(<span class="string">‘Hello!’</span>);}</li><br><li>B.prototype = <span class="keyword">new</span> A();</li><br><li><span class="keyword">new</span> B().hello();</li><br></ol><br></div><br><p>这就是 JavaScript 的所谓“继承”了，其实质就是属性的拷贝，这里利用了 prototype 来实现。如果不用 prototype，那就用循环了，效果是一样的。所谓“多重继承”，自然就是到处拷贝了。</p><br><p>JavaScript 中面向对象的原理，就是上面这些了。自始至终我都没提到“类”的概念，因为 JavaScript 本来就没有“类”这个东西。面向对象可以没有类吗？当然可以。先有类，然后再有对象，这本来就不合理，因为类本来是从对象中归纳出来的，先有对象再有类，这才合理。像下面这样的：</p><br><div id="" class="dp-highlighter"><br><div class="bar"><br><div class="tools">Js代码 <embed src="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash" width="14" height="15"> <a title="收藏这段代码"><img class="star" src="http://www.iteye.com/images/icon_star.png" data-original="http://www.iteye.com/images/icon_star.png" onerror="this.onerror=null;this.src='http://www.old.com/wp-content/themes/BYMT/images/images_error.jpg'" alt="收藏代码"></a></div><br></div><br><ol class="dp-c" start="1"><br><li><span class="keyword">var</span> o = {}; <span class="comment">// 我发现了一个东西。</span></li><br><li>o.eat = <span class="keyword">function</span>(){<span class="keyword">return</span> <span class="string">“I am eating.”</span>}  <span class="comment">// 我发现它会吃；</span></li><br><li>o.sleep = <span class="keyword">function</span>(){<span class="keyword">return</span> <span class="string">“ZZZzzz…”</span>}  <span class="comment">// 我发现它会睡；</span></li><br><li>o.talk = <span class="keyword">function</span>(){<span class="keyword">return</span> <span class="string">“Hi!”</span>} <span class="comment">// 我发现它会说话；</span></li><br><li>o.think = <span class="keyword">function</span>(){<span class="keyword">return</span> <span class="string">“Hmmm…”</span>} <span class="comment">// 我发现它还会思考。</span></li><br><li></li><br><li><span class="keyword">var</span> Human = <span class="keyword">new</span> Function(); <span class="comment">// 我决定给它起名叫“人”。</span></li><br><li>Human.prototype = o; <span class="comment">// 这个东西就代表了所有“人”的概念。</span></li><br><li></li><br><li><span class="keyword">var</span> h = <span class="keyword">new</span> Human(); <span class="comment">// 当我发现其他同它一样的东西，</span></li><br><li>alert(h.talk()) <span class="comment">// 我就知道它也是“人”了！</span></li><br></ol><br></div><br><p>&nbsp;</p><br><p>&nbsp;</p><br><p>————————————————————————————————<br><br>文章出自 yiding-he.iteye.com，转载请注明作者和出处。</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-204ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/204ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/204ver/">JavaScript-call:简单理解call</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>理解转自<a href="http://www.jb51.net/article/22963.htm" target="_blank" rel="external">http://www.jb51.net/article/22963.htm</a></p><br><pre class="lang:default decode:true ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-apply与call&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>    function num1(a,b){<br>        alert(a+b);<br>    }<br>    function num2(a,b){<br>        alert(“a<em>b:”+a</em>b);<br>    }<br>    num2.call(num1,10,20)//这个例子中的意思就是用 num2 来替换 num1，num2.call(num1,10,20) == num2(10,20) ，所以运行结果为：alert(200); // 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。<br><br>    function abb(name){<br>        this.name=name<br>        this.showName=function(){alert(“abb name:”+this.name)}<br>    }<br>    function ann(name){<br>        this.name=name<br>    }<br><br>    var abb1=new abb(“abb1的name”);<br>    var ann1=new ann(“ann的name”);<br><br>    abb1.showName.call(ann1);//首先 ann是没有showName函数 但是我们又让ann1来执行showName函数,于是通过call继承下来了<br>    //showName=function(){alert(“abb name”+this.name)} 这里的this.name指的是 ann的name<br><br>    //以下解释来自<a href="http://www.jb51.net/article/22963.htm" target="_blank" rel="external">http://www.jb51.net/article/22963.htm</a><br>    //注意，call 的意思是把 abb1 的方法放到ann1上执行，原来ann1是没有showName() 方法，现在是把abb1 的showName()方法放到 ann 上来执行，所以this.name 应该是 ann，执行的结果就是 ：alert（”ann name”）;<br>//  怎么样，觉得有意思了吧，可以让a对象来执行b对象的方法，这是java程序员所不敢想的。还有更有趣的，可以用 call 来实现继承<br><br>    function Class1() {<br>        this.showTxt = function(txt) {<br>            alert(txt);<br>        }<br>    }<br><br>    function Class2() {<br>        Class1.call(this);<br>    }<br>    var c2 = new Class2();<br>    c2.showTxt(“cc”);<br>    //这样 Class2 就继承Class1了，Class1.call(this) 的 意思就是使用 Class1 对象代替this对象，那么 Class2 中不就有Class1 的所有属性和方法了吗，c2 对象就能够直接调用Class1 的方法以及属性了，执行结果就是：alert（“cc”）;<br>    function Class10() {<br>        this.showSub = function(a, b) {<br>            alert(a - b);<br>        }<br>    }<br><br>    function Class11() {<br>        this.showAdd = function(a, b) {<br>            alert(a + b);<br>        }<br>    }<br><br>    function Class3() {<br>        Class10.call(this);<br>        Class11.call(this);<br>    }<br>    var c3 =new Class3();<br>    c3.showAdd(10,20)<br><br>    //apply与call区别在于 call 的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments<br><br><br><br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-206ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/206ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/206ver/">JavaScript:节点-2:再次理解下节点</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本来想写详细点,发现自己理解还不够 先放着 以后再填</p><br><pre class="lang:default decode:true ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-再次理解childNodes&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>        function knowChildnodes(){<br>            var get_childnodes=document.body.childNodes;<br>            console.log(get_childnodes);//当前页面有多少元素<br>            var get_childnodes0=document.body.childNodes[0];<br>            console.log(get_childnodes0);//第0个的元素是什么<br>            var get_did=document.getElementById(“did”);//获取div<br>            console.log(get_did.childNodes);//输出div下的元素<br>            console.log(get_did.childNodes[1].nodeName);//从控制台可以看到[0]是一个#text文本 [1]才是元素<br>            console.log(get_did.firstChild.nodeName);//也可以使用firstChild获取到第一个[0]元素的名字<br>            console.log(get_did.childNodes.length.nodeName);//这样是找不到的 因为在childNodes是从0开始 获取到最后一个元素可以使用<br>            console.log(get_did.childNodes[get_did.childNodes.length-2].nodeName)//获取到最后一个元素属性名字 -1是#text文本<br>            console.log(get_did.lastChild.nodeName)//获取到最后一个元素的名字<br><br><br>            //兄弟节点,父级节点<br>            console.log(“我是分隔符,下面开始兄弟节点 父级节点”);<br>            console.log(“第0个元素是#text 那么他的下一个元素应该是p||”+get_did.childNodes[0].nextSibling.nodeName);//<br>            console.log(“第1个元素是p,那么他的下一个元素应该是p的文本||”+get_did.childNodes[1].nextSibling.nodeName);//<br>            console.log(“第2个元素是p的文本 那么他的下一个元素应该是p||”+get_did.childNodes[2].nextSibling.nodeName);<br>            //以上是下级的结构 那么同级的结构是什么呢？<br>            var get_h1=document.getElementsByTagName(“h1”);<br>            console.log(get_h1[0].nextSibling.nodeValue);//文本节点…值是回车符<br>            //坑待理解后再填<br><br>        }<br><br><br>        window.onload=function(){<br>            knowChildnodes();<br>        }<br><br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;hello&lt;/h1&gt;<br>    &lt;div id=”did”&gt;<br>        &lt;p&gt;我是soul&lt;/p&gt;<br>        &lt;p&gt;灵魂追逐者&lt;/p&gt;<br>        &lt;p&gt;放荡的灵魂&lt;/p&gt;<br>    &lt;/div&gt;<br>    &lt;h1&gt;第二个soul&lt;h1&gt;<br>    &lt;p&gt;我是规则之外的灵魂&lt;/p&gt;<br>    &lt;p&gt;我是规则之外的灵魂&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-207ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/207ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/207ver/">JavaScript-简单动画5:闪瞎你狗眼的打字机</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一个很简单的打字机..本来想自己不去百度写一个打字机的..但是技术还是不够啊..所以就去网上看了一下 然后理解了思路 自己写了一个出来</p><br><pre class="lang:default decode:true  ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-打字机&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>    //思路<br>    //每1秒打一个字,每打一个字更改一下颜色<br>    //1.创建一个P元素<br>    //2.创建一个动画.<br>    //2.5 创建一个文本数组<br>    //3.创建一个颜色数组<br>    //4.把颜色数组应用到文本上<br>    var new_p =document.createElement(“p”);//全局函数 意思是新建一个标签p<br>    var txt=”hello soul next fllow myeles night die”;//创建一个文本数组<br>    var i=0,n=0;//设置i=0,,n=0<br>    var color_1=[“bule”,”green”,”red”,”rgb(100,200,300)”,”black”]//创建一个颜色数组<br>    function test(){//开始打字+闪瞎你狗眼<br>        var p_txt =document.createTextNode(txt.charAt(i));//创建一个文本节点,文本节点内容等于文本数组的第[i]个元素<br>        i++;//i++<br>        new_p.appendChild(p_txt);//在p标签下添加文本节点<br>        new_p.style.color=color_1[n];//设置p标签的颜色等于颜色数组的第[n]个元素颜色<br>        n++;//n++<br>        document.body.appendChild(new_p);//在文档根目录添加p<br>        var anmi=setTimeout(test,500);//每500毫秒执行test函数<br>        if(n==color_1.length){//如果n等于颜色数组的长度<br>            n=0;//重新开始计数<br><br>        }<br>        if(i==txt.length){//如果i等于文本数组的长度<br>            clearTimeout(anmi);//停止动画<br><br>        }<br><br>    }<br><br>    window.onload=function(){<br>        test()<br>    }<br><br><br><br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-208ver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/21/208ver/" class="article-date">
  	<time datetime="2015-10-21T14:57:05.757Z" itemprop="datePublished">2015-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/208ver/">JavaScript-内置对象-2:数组的内置对象是shenmegui?</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本章介绍了数组内置对象的以下内置对象,可以复制代码保存到本地文件后观看哦</p><br><blockquote><br><ol><br><li>数组对象之长度对象</li><br><li>转换数组为字符串</li><br><li>数组的元素插入</li><br><li>数组之排序</li><br><li>数组之 相加</li><br><li>数组之 插入 替换 删除</li><br><li>数组之 位置</li><br><li>数组之迭代方法</li><br><li>归并数组</li><br></ol><br></blockquote><br><pre class="lang:default decode:true ">&lt;!doctype html&gt;<br>&lt;html lang=”en”&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”UTF-8”&gt;<br>    &lt;title&gt;JS-内置对象-2&lt;/title&gt;<br>    &lt;script type=”text/javascript”&gt;<br>    function soulArr(){<br>        //数组对象<br><br>        //数组对象之长度对象<br>        var soul_arr1=[“hello”,”soul”,”i\’m”,”soul seeker”]//这里使用了转义字符\’<br>        console.log(“soul_arr1长度是多少”+soul_arr1.length);//soul_arr1有四个元素输出4<br>        soul_arr1.length=3;//设置长度会删除后面的元素<br>        console.log(“设置长度是3,删除了最后一个长度,那么现在数组内容是:”+soul_arr1);<br>        soul_arr1[5]=”new soul”;<br>        console.log(“新增加了一个元素,那么现在数组内容是:”+soul_arr1);//hello,soul,i’m,,,new soul  中间多出了两个逗号 是因为我们在上次设置了长度为3 然后我们又在第5个添加了元素, 所以中间没有值要写逗号<br><br>        soul_arr2=[“hello”,”soul”];<br>        soul_arr2[soul_arr2.length]=”seeker”;<br>        console.log(“在数组最后添加一个元素”+soul_arr2);<br>        soul_arr2[soul_arr2.length-1]=”new seeker”//更改数组最后一个元素内容 为什么是-1 因为长度是2 但是数组从0开始 所以要-1<br>        console.log(“更改数组最后一个元素内容”+soul_arr2);<br><br>        //转换数组为字符串<br>        console.log(“转换数组为字符串”+soul_arr2.toString());<br>        console.log(“使用不同的符号来作为数组转为字符串的分隔符”+soul_arr2.join(“||”));<br><br>        //数组的元素插|入<br>        var soul_arr3=[“hello”];<br>        soul_arr3.push(“soul”,”seeker”);<br>        soul_arr3[3]=”new soul”;//稍微理解一下 数组是从0开始0,1,2(在最后添加了两个元素),[3]就是第4个元素<br>        console.log(“在数组的最后添加元素”+soul_arr3);<br>        soul_arr3.pop()<br>        console.log(“移除了最后一个元素”+soul_arr3);<br>        var fsoul_arr3=soul_arr3.shift();//取得数组的第一项并且删除第一项<br>        console.log(“数组取出的第一项是:”+fsoul_arr3+”|现在数组内容为:”+soul_arr3);<br>        var f1soul_arr3=soul_arr3.shift();//再取出第一项<br>        console.log(“数组取出的第一项是:”+f1soul_arr3+”|现在数组内容为:”+soul_arr3);<br>        soul_arr3.push(“new seeker”,”new shenshi”,”new hello”);//添加几个元素<br>        var nsoul_arr3=soul_arr3.unshift(“ok”,”yes”);<br>        console.log(“在数组前端推入两项 内容是:”+nsoul_arr3+”|当前数组内容为:”+soul_arr3);<br><br>        //数组之排序<br>        var soul_arr4=[“b”,”a”,”d”,”c”];<br>        soul_arr4.sort();//从低到高排序<br>        console.log(“从低到高排序”+soul_arr4);<br>        soul_arr4.reverse();//翻转数组排序<br>        console.log(“翻转数组排序”+soul_arr4);<br>        //sort排序有一个问题 在进行比较时 因为9位于15前面 所以会把9放后面<br>        //…下文数组不是排序好的嘛..为何还要多此一举<br>        var soul_arr5 =[5,9,15,20,25];<br>        soul_arr5.sort();<br>        console.log(“排序正确的数组再进行排序:”+soul_arr5);<br>        //怎么解决呢？编写了一个函数来判断<br>        soul_arr5.sort(compaer);//利用 -1 1 0就解决了<br>        console.log(“解决后:”+soul_arr5);//从低到高<br><br>        //数组之 相加<br>        var soul_arr6=[“hello”,”world”];<br>        var soul_arr7=[“none”];<br>        soul_arr6 += soul_arr7;//直接相加会发现会把数组转换为字符串再进行相加<br>        console.log(“直接相加”+soul_arr6+”类型”+typeof soul_arr6);<br><br>        var soul_arr6=[“我是一”,”我是二”,”我是三”,”我是四”];<br>        var soul_arr7=[“我是六”,”我是七”];<br>        var soul_arr8=soul_arr6.concat(soul_arr7);//相当于复制了一份 然后再在数组末尾插入soul_arr7 不会破坏原来的数组<br>        console.log(“在数组末尾插入一个数组”+soul_arr8);<br>        //数组之 插入 替换 删除<br>        //删除<br>        var soul_arr9=[“我是0”,”我是1”,”我是2”,”我是3”,”我是4”];<br>        var del_soul_arr9=soul_arr9.splice(0,2);//删除第一项与第二项 0与2之间不就是第一项和第二项嘛？<br>        console.log(“删除的数组为:”+del_soul_arr9+”当前数组内容为:”+soul_arr9);<br>        //插入<br>        var add_soul_arr9=soul_arr9.splice(2,0,”我是在\’我是4\’之前插入的”,”再插入一个”);//从第二项插入,因为上面删除了两项 所以第二项应该是”我是4”<br>        console.log(“插入的元素为:”+add_soul_arr9+”|当前数组内容为:”+soul_arr9);<br>        //替换<br>        var soul_arr10=[“我是0”,”我是1”,”我是2”,”我是3”,”我是4”];<br>        var rep_soul_arr10=soul_arr10.splice(0,1,”我是插入的”,”我是插入的-2”);<br>        console.log(“删除的元素为:”+rep_soul_arr10+”|当前数组内容:”+soul_arr10);//替换”我是0”后再插入一个元素<br><br>        //数组之 位置<br>        //从正向开始查找<br>        var soul_arr10=[“1”,4,”1”,1,2,3,”1”];<br>        console.log(“正向查找:”+soul_arr10.indexOf(“1”));//indexOf查找时会使用全等查找 并且查到到了后会输出元素在数组的位置<br>        //反向查找<br>        console.log(“反向查找:”+soul_arr10.lastIndexOf(“1”));//反向查找会查找到最远的那个<br>        //还有分段查询<br>        console.log(“从1开始查询而非0(数组第一个元素)”+soul_arr10.indexOf(“1”,1));//结果是2<br>        console.log(“从反向的6开始查询而非反向的0|”+soul_arr10.lastIndexOf(“1”,6))//结果是6<br><br>        //数组之迭代方法<br>        var soul_arr11=[1,2,3,4,5,6,7];<br>        //将大于5的元素组成数组<br>        var soul5_arr11=soul_arr11.filter(function(num){<br>            return(num&gt;5);<br>        })<br>        console.log(“新组成数组:”+soul5_arr11+”|原来的数组”+soul_arr11);//发现不会影响到原来的数组<br>        //将每个数组乘以2<br>        var soul2_arr11=soul_arr11.map(function(num){<br>            return(num*2);<br>        })<br>        console.log(“乘以后的数组:”+soul2_arr11);<br><br>        //归并数组<br>        //数组内容进行相加<br>        var soul_arr12=soul_arr11.reduce(function(q,h){//reduce是从正向开始相加 也可以从反向开始<br>            return(q+h);<br>        })//传递两个参数 q是前一个值,h是当前值<br>        console.log(“相加结果:”+soul_arr12);<br>        var soul_arr13=soul_arr11.reduceRight(function(q,h){<br>            return(q+h);<br>        })<br>        console.log(“反向相加,因为是简单相加所以都一样”+soul_arr13);<br><br><br>    }<br>    function compaer(a,b){<br>        if(a&gt;b){//比较两个值 如果前面的大于后面的<br>            return 1;//把后面的放前面 所以返回1<br><br>        }<br>        if(a&lt;b){//比较两个值 如果前面的小于后面的<br>            return -1;//把前面的放后面 返回-1<br><br>        }<br>        if(a=b){//如果相等<br>            return 0;//不做更改<br>        }<br>    }<br><br><br><br><br>    window.onload=function(){<br>        soulArr();<br><br>    }<br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br><p>&nbsp;</p><br><p>&nbsp;</p>





      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Soul
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>